<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.84">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Liudmila Pishchagina">
<meta name="author" content="Guillem Rigaill">
<meta name="author" content="Vincent Runge">
<meta name="dcterms.date" content="2023-05-22">
<meta name="keywords" content="Multiple change point detection, dynamic programming, functional pruning, computational geometry">

<title>Geometric-Based Pruning Rules For Change Point Detection in Multiple Independent Time Series</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="template-computo-R_files/libs/clipboard/clipboard.min.js"></script>
<script src="template-computo-R_files/libs/quarto-html/quarto.js"></script>
<script src="template-computo-R_files/libs/quarto-html/popper.min.js"></script>
<script src="template-computo-R_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="template-computo-R_files/libs/quarto-html/anchor.min.js"></script>
<link href="template-computo-R_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="template-computo-R_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="template-computo-R_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="template-computo-R_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="template-computo-R_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Geometric-Based Pruning Rules For Change Point Detection in Multiple Independent Time Series</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://github.com/lpishchagina">Liudmila Pishchagina</a> <a href="https://orcid.org/0000-0000-0000-0000" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="http://www.math-evry.cnrs.fr/">
                  UEVE
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://johndoe.someplace.themoon.org">Guillem Rigaill</a> <a href="https://orcid.org/0000-0000-0000-0000" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  INRAE, UEVE
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://johndoe.someplace.themoon.org">Vincent Runge</a> <a href="https://orcid.org/0000-0000-0000-0000" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="http://www.math-evry.cnrs.fr/">
                  UEVE
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 22, 2023</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">May 22, 2023</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Multiple change point detection, dynamic programming, functional pruning, computational geometry</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>We consider the problem of detecting multiple changes in multiple independent time series. It can be expressed as finding the segmentation that minimizes a given cost function. We focus on dynamic programming algorithms that solve this minimization problem exactly. When the number of changes is proportional to data length, an inequality-based pruning rule encoded in the PELT algorithm leads to a linear time complexity. Another type of pruning, called functional pruning, gives a close-to-linear time complexity whatever the number of changes, but only for a univariate cost function. We propose a few extensions of functional pruning for multiple independent time series based on the use of simple geometric shapes (balls and hyperrectangles). We focus on the Gaussian case, but some of our rules can be extended to the exponential family. In a simulation study, we compare the computational efficiency of different geometric-based pruning rules and show that for small dimensions (2, 3, 4) some of them ran significantly faster than inequality-based approaches in particular when the underlying number of changes is small compared to the data length.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-changesMulti" id="toc-sec-changesMulti" class="nav-link" data-scroll-target="#sec-changesMulti"><span class="header-section-number">2</span> Functional Pruning for Multiple Time Series</a>
  <ul class="collapse">
  <li><a href="#sec-model" id="toc-sec-model" class="nav-link" data-scroll-target="#sec-model"><span class="header-section-number">2.1</span> Model and Cost</a></li>
  <li><a href="#sec-UpdateRule" id="toc-sec-UpdateRule" class="nav-link" data-scroll-target="#sec-UpdateRule"><span class="header-section-number">2.2</span> Functional Pruning Dynamic Programming Algorithm</a></li>
  <li><a href="#sec-geometry" id="toc-sec-geometry" class="nav-link" data-scroll-target="#sec-geometry"><span class="header-section-number">2.3</span> Geometric Formulation of Functional Pruning</a></li>
  </ul></li>
  <li><a href="#sec-GeomFPOP" id="toc-sec-GeomFPOP" class="nav-link" data-scroll-target="#sec-GeomFPOP"><span class="header-section-number">3</span> Geometric Functional Pruning Optimal Partitioning</a>
  <ul class="collapse">
  <li><a href="#sec-principle" id="toc-sec-principle" class="nav-link" data-scroll-target="#sec-principle"><span class="header-section-number">3.1</span> General Principle of GeomFPOP</a></li>
  </ul></li>
  <li><a href="#sec-approximation" id="toc-sec-approximation" class="nav-link" data-scroll-target="#sec-approximation"><span class="header-section-number">4</span> Approximation Operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span></a>
  <ul class="collapse">
  <li><a href="#s-type-approximation" id="toc-s-type-approximation" class="nav-link" data-scroll-target="#s-type-approximation"><span class="header-section-number">4.1</span> S-type Approximation</a></li>
  <li><a href="#r-type-approximation" id="toc-r-type-approximation" class="nav-link" data-scroll-target="#r-type-approximation"><span class="header-section-number">4.2</span> R-type Approximation</a></li>
  </ul></li>
  <li><a href="#sec-study" id="toc-sec-study" class="nav-link" data-scroll-target="#sec-study"><span class="header-section-number">5</span> Simulation Study of GeomFPOP</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="template-computo-R.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>A National Research Council report (<span class="citation" data-cites="NRCreport2013">Data et al. (<a href="#ref-NRCreport2013" role="doc-biblioref">2013</a>)</span>) has identified change point detection as one of the “inferential giants” in massive data analysis. Detecting change points, either a posteriori or online, is important in areas as diverse as bioinformatics (<span class="citation" data-cites="olshen2004circular">Olshen et al. (<a href="#ref-olshen2004circular" role="doc-biblioref">2004</a>)</span>, <span class="citation" data-cites="Picard2005">Picard et al. (<a href="#ref-Picard2005" role="doc-biblioref">2005</a>)</span>), econometrics (<span class="citation" data-cites="bai2003computation">Bai and Perron (<a href="#ref-bai2003computation" role="doc-biblioref">2003</a>)</span>, <span class="citation" data-cites="Aue_monitoring">Aue et al. (<a href="#ref-Aue_monitoring" role="doc-biblioref">2006</a>)</span>), medicine (<span class="citation" data-cites="Bosc2003">Bosc et al. (<a href="#ref-Bosc2003" role="doc-biblioref">2003</a>)</span>, <span class="citation" data-cites="Staudacher2005ANM">Staudacher et al. (<a href="#ref-Staudacher2005ANM" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="Malladi2013OnlineBC">Malladi, Kalamangalam, and Aazhang (<a href="#ref-Malladi2013OnlineBC" role="doc-biblioref">2013</a>)</span>), climate and oceanography (<span class="citation" data-cites="Reeves2007">Reeves et al. (<a href="#ref-Reeves2007" role="doc-biblioref">2007</a>)</span>, <span class="citation" data-cites="DucrRobitaille2003">Ducré-Robitaille, Vincent, and Boulet (<a href="#ref-DucrRobitaille2003" role="doc-biblioref">2003</a>)</span>, <span class="citation" data-cites="Killick">Killick, Fearnhead, and Eckley (<a href="#ref-Killick" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="Naoki2010">Naoki and Kurths (<a href="#ref-Naoki2010" role="doc-biblioref">2010</a>)</span>), finance (<span class="citation" data-cites="Andreou">Andreou and Ghysels (<a href="#ref-Andreou" role="doc-biblioref">2002</a>)</span>, <span class="citation" data-cites="Fryzlewicz_2014">Fryzlewicz (<a href="#ref-Fryzlewicz_2014" role="doc-biblioref">2014</a>)</span>), autonomous driving (<span class="citation" data-cites="galceran2017multipolicy">Galceran et al. (<a href="#ref-galceran2017multipolicy" role="doc-biblioref">2017</a>)</span>), entertainment (<span class="citation" data-cites="Rybach">Rybach et al. (<a href="#ref-Rybach" role="doc-biblioref">2009</a>)</span>, <span class="citation" data-cites="Radke">Radke et al. (<a href="#ref-Radke" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="Davis2006">Davis, Lee, and Rodriguez-Yam (<a href="#ref-Davis2006" role="doc-biblioref">2006</a>)</span>), computer vision (<span class="citation" data-cites="ranganathan2012pliss">Ranganathan (<a href="#ref-ranganathan2012pliss" role="doc-biblioref">2012</a>)</span>) or neuroscience (<span class="citation" data-cites="jewell2020fast">Jewell, Fearnhead, and Witten (<a href="#ref-jewell2020fast" role="doc-biblioref">2019</a>)</span>). The most common and prototypical change point detection problem is that of detecting changes in mean of a univariate Gaussian signal and a large number of approaches have been proposed to this problem (see among many others <span class="citation" data-cites="Yao">Yao (<a href="#ref-Yao" role="doc-biblioref">1984</a>)</span>, <span class="citation" data-cites="Lebarbier2005">Lebarbier (<a href="#ref-Lebarbier2005" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="harchaoui2010multiple">Harchaoui and Lévy-Leduc (<a href="#ref-harchaoui2010multiple" role="doc-biblioref">2010</a>)</span>, <span class="citation" data-cites="Frick2013">Frick, Munk, and Sieling (<a href="#ref-Frick2013" role="doc-biblioref">2013</a>)</span>, <span class="citation" data-cites="fryzlewicz2020detecting">Anastasiou and Fryzlewicz (<a href="#ref-fryzlewicz2020detecting" role="doc-biblioref">2022</a>)</span> and the reviews <span class="citation" data-cites="truong2020selective">Truong, Oudre, and Vayatis (<a href="#ref-truong2020selective" role="doc-biblioref">2020</a>)</span>, <span class="citation" data-cites="aminikhanghahi2017survey">Aminikhanghahi and Cook (<a href="#ref-aminikhanghahi2017survey" role="doc-biblioref">2017</a>)</span>).</p>
<p><em>Penalized cost methods.</em> Some of these methods optimize a penalized cost function (see for example <span class="citation" data-cites="Lebarbier2005">Lebarbier (<a href="#ref-Lebarbier2005" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="Auger">Auger and Lawrence (<a href="#ref-Auger" role="doc-biblioref">1989</a>)</span>, <span class="citation" data-cites="jackson2005algorithm">Jackson et al. (<a href="#ref-jackson2005algorithm" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="Killick">Killick, Fearnhead, and Eckley (<a href="#ref-Killick" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="Rigaill2010">Rigaill (<a href="#ref-Rigaill2010" role="doc-biblioref">2010</a>)</span>, <span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span>). These methods have good statistical guarantees (<span class="citation" data-cites="Yao">Yao (<a href="#ref-Yao" role="doc-biblioref">1984</a>)</span>, <span class="citation" data-cites="lavielle2000least">Lavielle and Moulines (<a href="#ref-lavielle2000least" role="doc-biblioref">2000</a>)</span>, <span class="citation" data-cites="Lebarbier2005">Lebarbier (<a href="#ref-Lebarbier2005" role="doc-biblioref">2005</a>)</span>) and have shown good performances in benchmark simulations (<span class="citation" data-cites="fearnhead2018detecting">Fearnhead, Maidstone, and Letchford (<a href="#ref-fearnhead2018detecting" role="doc-biblioref">2018</a>)</span>) and on many applications ( <span class="citation" data-cites="lai2005comparative">Lai et al. (<a href="#ref-lai2005comparative" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="liehrmann2021increased">Liehrmann, Rigaill, and Hocking (<a href="#ref-liehrmann2021increased" role="doc-biblioref">2021</a>)</span>). From a computational perspective, these methods rely on dynamic programming algorithms that are at worst quadratic in the size of the data, <span class="math inline">n</span>. However using inequality-based and functional pruning techniques (<span class="citation" data-cites="Rigaill2010">Rigaill (<a href="#ref-Rigaill2010" role="doc-biblioref">2010</a>)</span>, <span class="citation" data-cites="Killick">Killick, Fearnhead, and Eckley (<a href="#ref-Killick" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span>) the average run times are typically much smaller allowing to process very large profiles (<span class="math inline">n&gt; 10^5</span>) in a matter of seconds or minutes. In detail, for one time series:</p>
<ul>
<li>if the number of change points is proportional to <span class="math inline">n</span> both PELT (inequality-based pruning) and FPOP (functional pruning) (<span class="citation" data-cites="Killick">Killick, Fearnhead, and Eckley (<a href="#ref-Killick" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span>) are on average linear.</li>
<li>if the number of change points is fixed, FPOP is quasi-linear (on simulations) while PELT is quadratic (<span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span>).</li>
</ul>
<p><em>Multivariate extensions.</em> In this paper, we focus on the multivariate problem assuming the cost function or log-likelihood of a segment (denoted <span class="math inline">\mathcal C</span>) can be decomposed as a sum over all <span class="math inline">p</span> dimensions. Informally that is <span class="math display">
\mathcal C(segment) = \sum_{k=1}^{p} \mathcal C(segment, \hbox{ time series } k)\,.
</span> In this context, the PELT algorithm can easily be extended for multiple time series. However, as for the univariate case, it will be algorithmically efficient only if the number of change points is large compared to <span class="math inline">n</span>. In this paper, we study the extension of functional pruning techniques (and more specifically FPOP) to the multivariate case.</p>
<p>At each iteration, FPOP updates the set of parameter values for which a change position <span class="math inline">\tau</span> is optimal. As soon as this set is empty the change is pruned. For univariate time series, this set is a union of intervals in <span class="math inline">\mathbb{R}</span>. For multi-parametric models, this set is equal to the intersection and difference of convex sets in <span class="math inline">\mathbb{R}^p</span> (<span class="citation" data-cites="runge2020finite">Runge (<a href="#ref-runge2020finite" role="doc-biblioref">2020</a>)</span>). It is typically non-convex, hard to update, and deciding whether it is empty or not is not straightforward.</p>
<p>In this work, we present a new algorithm, called Geometric Functional Pruning Optimal Partitioning (GeomFPOP). The idea of our method is to approximate the sets that are updated at each iteration of FPOP using simpler geometric shapes. Their simplicity of description and simple updating allow for a quick emptiness test.</p>
<p>The paper has the following structure. In <a href="#sec-changesMulti" class="quarto-xref">Section&nbsp;2</a> we introduce the penalized optimization problem for segmented multivariate time series. We then review the existing pruned dynamic programming methods for solving this problem. We define the geometric problem that occurs when using functional pruning. The new method, called GeomFPOP, is described in Section <a href="#sec-GeomFPOP" class="quarto-xref">Section&nbsp;3</a> and based on approximating intersection and exclusion set operators. In <a href="#sec-approximation" class="quarto-xref">Section&nbsp;4</a> we introduce two approximation types (sphere-like and rectangle-like) and define the approximation operators for each of them. We then compare in <a href="#sec-study" class="quarto-xref">Section&nbsp;5</a> the empirical efficiency of GeomFPOP with PELT on simulated data.</p>
</section>
<section id="sec-changesMulti" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Functional Pruning for Multiple Time Series</h1>
<section id="sec-model" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-model"><span class="header-section-number">2.1</span> Model and Cost</h2>
<p>We consider the problem of change point detection in multiple time series of length <span class="math inline">n</span> and dimension <span class="math inline">p</span>. Our aim is to partition time into segments, such that in each segment the parameter associated to each time series is constant. For a time series <span class="math inline">y</span> we write <span class="math inline">y = y_{1:n}=(y_1,\dots, y_n) \in(\mathbb{R}^p)^n</span> with <span class="math inline">y_i^k</span> the <span class="math inline">k</span>-th component of the <span class="math inline">p</span>-dimensional point <span class="math inline">y_i\in\mathbb{R}^p</span> in position <span class="math inline">i</span> in vector <span class="math inline">y_{1:n}</span>. We also use the notation <span class="math inline">y _{i:j} = (y_i,\dots, y_j)</span> to denote points from index <span class="math inline">i</span> to <span class="math inline">j</span>. If we assume that there are <span class="math inline">M</span> change points in a time series, this corresponds to time series splits into <span class="math inline">M+1</span> distinct segments. Each segment <span class="math inline">m \in \{1,\dots, M+1\}</span> is generated by independent random variables from a multivariate distribution with the segment-specific parameter <span class="math inline">\theta_m = (\theta_m^1,\dots, \theta_m^p) \in \mathbb{R}^p</span>. A segmentation with <span class="math inline">M</span> change points is defined by the vector of integers <span class="math inline">\tau =(\tau_0 = 0, \tau_1,\dots,\tau_M,\tau_{M+1}=n)</span>. Segments are given by the sets of indices <span class="math inline">\{\tau_i+1,\dots, \tau_{i+1}\}</span> with <span class="math inline">i</span> in <span class="math inline">\{0,1,\ldots,M\}</span>.</p>
<p>We define the set <span class="math inline">S_t</span> of all possible change point locations related to the segmentation of data points between positions <span class="math inline">1</span> to <span class="math inline">t</span> as <span class="math display">
S_t = \{\tau = (\tau_0,\tau_1,\dots,\tau_M, \tau_{M+1}) \in \mathbb{N}^{M+2} | 0=\tau_{0} &lt;\tau_1 &lt; \dots &lt; \tau_M &lt; \tau_{M+1}=t\}\,.
</span> Usually the number of changes <span class="math inline">M</span> is unknown, and has to be estimated. Many approaches to detecting change points define a cost function for segmentation using the opposite log-likelihood (times two). Here the opposite log-likelihood (times two) linked to data point <span class="math inline">y_j</span> is given by function <span class="math inline">\theta \mapsto \Omega(\theta,y_j)</span>, where <span class="math inline">\theta = (\theta^1,\dots, \theta^p) \in \mathbb R^p</span>. Over a segment from <span class="math inline">i</span> to <span class="math inline">t</span>, the parameter remains the same and the segment cost <span class="math inline">\mathcal C</span> is given by <span id="eq-Cy_it"><span class="math display">
        \begin{gathered}
            \mathcal C(y_{i:t}) = \min_{\theta \in \mathbb{R}^p} \sum_{j=i}^{t}\Omega(\theta, y_j) = \min_{\theta \in \mathbb{R}^p} \sum_{j=i}^{t} \left(\sum_{k=1}^{p} \omega(\theta^k, y_j^k)\right)\,,
        \end{gathered}
\tag{1}</span></span><br>
with <span class="math inline">\omega</span> the atomic likelihood function associated with <span class="math inline">\Omega</span> for each univariate time series. This decomposition is made possible by the independence hypothesis between dimensions. Notice that function <span class="math inline">\omega</span> could have been dimension-dependent with a mixture of different distributions (Gauss, Poisson, negative binomial, etc.). In our study, we consider the same data model for all dimensions.</p>
<p>We consider a penalized version of the cost by a penalty <span class="math inline">\beta &gt; 0</span>, because without a penalty we would end up with <span class="math inline">n</span> segments. Summing over all segments we end up with a penalty that is linear in the number of segments. Such choice is common in the literature (<span class="citation" data-cites="yao1988estimating">Yao (<a href="#ref-yao1988estimating" role="doc-biblioref">1988</a>)</span>, <span class="citation" data-cites="Killick">Killick, Fearnhead, and Eckley (<a href="#ref-Killick" role="doc-biblioref">2012</a>)</span>) although some other penalties have been proposed (<span class="citation" data-cites="Zhang2007">Zhang and Siegmund (<a href="#ref-Zhang2007" role="doc-biblioref">2007</a>)</span>, <span class="citation" data-cites="Lebarbier2005">Lebarbier (<a href="#ref-Lebarbier2005" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="Verzelen2020">Verzelen et al. (<a href="#ref-Verzelen2020" role="doc-biblioref">2020</a>)</span>). The optimal penalized cost associated with our segmentation problem is then defined by <span id="eq-Q_n"><span class="math display">
    Q_n = \min_{\tau \in S_n} \sum_{i=0}^{M} \{\mathcal C(y_{(\tau_{i}+1):\tau_{i+1}})+\beta\}\,.
\tag{2}</span></span> The optimal segmentation <span class="math inline">\tau</span> is obtained by the argminimum in <a href="#eq-Q_n" class="quarto-xref">Equation&nbsp;2</a>.</p>
</section>
<section id="sec-UpdateRule" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-UpdateRule"><span class="header-section-number">2.2</span> Functional Pruning Dynamic Programming Algorithm</h2>
<p>The idea of the Optimal Partitioning (OP) method (<span class="citation" data-cites="jackson2005algorithm">Jackson et al. (<a href="#ref-jackson2005algorithm" role="doc-biblioref">2005</a>)</span>) is to search for the last change point defining the last segment in data <span class="math inline">y_{1:t}</span> at each iteration (with <span class="math inline">Q_0 = 0</span>), which leads to the recursion: <span id="eq-OP"><span class="math display">
Q_{t} = \min_{i\in\{0,\dots,t-1\}}\Big(Q_i + \mathcal C(y_{({i+1}:t})+ \beta \Big)\,.
\tag{3}</span></span></p>
<p><em>Functional description.</em> In the FPOP method we introduce a last segment parameter <span class="math inline">\theta = (\theta^1,\dots, \theta^p) \in \mathbb R^p</span> and define a functional cost <span class="math inline">\theta \mapsto Q_t(\theta)</span> depending on <span class="math inline">\theta</span>, that takes the following form: <span class="math display">
Q_t(\theta) = \min_{\tau \in S_t} \Big( \sum_{i=0}^{M-1} \{\mathcal C(y_{(\tau_{i}+1):\tau_{i+1}})+\beta\} + \sum_{j=\tau_{M}+1}^{t}\Omega(\theta, y_j) + \beta \Big)\,.
</span> As explained in <span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span>, we can compute the function <span class="math inline">Q_{t+1}(\cdot)</span> based only on the knowledge of <span class="math inline">Q_{t}(\cdot)</span> as for each integer <span class="math inline">t</span> from <span class="math inline">0</span> to <span class="math inline">n-1</span>. We have: <span id="eq-Q_tpl1"><span class="math display">
        Q_{t+1}(\theta) = \min \{Q_t(\theta),m_t +\beta \} + \Omega(\theta, y_{t+1})\,,
\tag{4}</span></span> for all <span class="math inline">\theta \in \mathbb{R}^p</span>, with <span class="math inline">m_t = \min_\theta Q_t(\theta)</span> and the initialization <span class="math inline">Q_0(\theta) = 0</span>, so that <span class="math inline">Q_1(\theta) = \Omega(\theta,y_1)</span>. By looking closely at this relation, we see that each function <span class="math inline">Q_t</span> is a piece-wise continuous function consisting of at most <span class="math inline">t</span> different functions on <span class="math inline">\mathbb R^p</span>, denoted <span class="math inline">q^i_t</span>: <span id="eq-Qq_it"><span class="math display">
    \begin{gathered}
        Q_t(\theta) = \min_{i \in \{1,\dots,t \}} \left\{q_t^i(\theta)\right\}\,,   
    \end{gathered}
\tag{5}</span></span> where the <span class="math inline">q_t^i</span> functions are given by explicit formulas: <span id="eq-q_it"><span class="math display">
    \begin{gathered}
        q_t^i(\theta) = m_{i-1} + \beta + \sum_{j = i}^{t} \Omega(\theta,y_j)\,,\quad\theta \in \mathbb R^p\,,\quad i = 1,\dots,t.  
    \end{gathered}
\tag{6}</span></span> and <span id="eq-m_im1"><span class="math display">
    m_{i-1} =  \min_{\theta \in \mathbb R^p}Q_{i-1}(\theta) = \min_{j \in \{ 1,\dots,i-1\}}\left\{ \min_{\theta \in \mathbb R^p}q_{i-1}^j(\theta) \right\}.
\tag{7}</span></span> It is important to notice that each <span class="math inline">q_t^i</span> function is associated with the last change point <span class="math inline">i-1</span> and the last segment is given by indices from <span class="math inline">i</span> to <span class="math inline">t</span>. Consequently, the last change point at step <span class="math inline">t</span> in <span class="math inline">y_{1:t}</span> is denoted as <span class="math inline">\hat\tau_t</span> <span class="math inline">( \hat \tau_t \le t-1)</span> and is given by <span id="eq-tau_t"><span class="math display">
        \begin{gathered}
            \hat\tau_t = Arg\,min_{i \in \{1,\dots,t\}} \left\{ \min_{\theta \in \mathbb{R}^p} q_t^i(\theta)\right\}-1.
        \end{gathered}
\tag{8}</span></span></p>
<p><em>Backtracking.</em> Knowing the values of <span class="math inline">\hat{\tau}_t</span> for all <span class="math inline">t=1, \dots, n</span>, we can always restore the optimal segmentation at time <span class="math inline">n</span> for <span class="math inline">y_{1:n}</span>. This procedure is called backtracking. The vector <span class="math inline">cp(n)</span> of ordered change points in the optimal segmentation of <span class="math inline">y_{1:n}</span> is determined recursively by the relation <span class="math inline">cp(n) = (cp(\hat \tau_n), \hat \tau_n)</span> with stopping rule <span class="math inline">cp(0)=\emptyset</span>.</p>
<p><em>Parameter space description.</em> Applying functional pruning requires a precise analysis of the recursion {eq-Q_tpl1} that depends on the property of the cost function~<span class="math inline">\Omega</span>. In what follows we consider three choices based on a Gaussian, Poisson, and negative binomial distribution assumption on the data. The exact formulas of these cost functions are given in <strong>?@sec-logLikeExamples</strong>.</p>
<p>We denote the set of parameter values for which the function <span class="math inline">q^i_t(\cdot)</span> is optimal as: <span id="eq-defZ"><span class="math display">
        \begin{gathered}
          Z_t^i = \left\{ \theta \in \mathbb R^p|Q_t(\theta) = q_{t}^i(\theta) \right\}, \quad i = 1,\dots,t.
        \end{gathered}
\tag{9}</span></span></p>
<p>The key idea behind functional pruning is that the <span class="math inline">Z_t^i</span> are nested (<span class="math inline">Z_{t+1}^i \subset Z_t^i</span>) thus as soon as we can prove the emptiness of one set <span class="math inline">Z_t^i</span>, we delete its associated <span class="math inline">q_t^i</span> function and do not have to consider its minimum anymore at any further iteration (proof in next <a href="#sec-geometry" class="quarto-xref">Section&nbsp;2.3</a>). In dimension <span class="math inline">p = 1</span> this is reasonably easy. In this case, the sets <span class="math inline">Z^i_t</span> (<span class="math inline">i=1,\dots, t</span>) are unions of intervals and an efficient functional pruning rule is possible by updating a list of these intervals for <span class="math inline">Q_{t}</span>. This approach is implemented in FPOP (<span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span>).</p>
<p>In dimension <span class="math inline">p \ge 2</span> it is not so easy anymore to keep track of the emptiness of the sets <span class="math inline">Z^i_t</span>. We illustrate the dynamics of the <span class="math inline">Z^i_t</span> sets in <a href="#fig-Figure1" class="quarto-xref">Figure&nbsp;1</a> in the bi-variate Gaussian case. Each color is associated with a set <span class="math inline">Z_t^i</span> (corresponding to a possible change at <span class="math inline">i-1</span>) for <span class="math inline">t</span> equal <span class="math inline">1</span> to <span class="math inline">5</span>. This plot shows that sets <span class="math inline">Z_t^i</span> can be non-convex.</p>
<div id="fig-Figure1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Figure 1 Z sets over time set_seed_617.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: The sets <span class="math inline">Z^i_t</span> over time for the bi-variate independent Gaussian model on time series without change <span class="math inline">y= \left \{\{0,29; 1,86; 0,9; -1,26; 1,22\},\{ 1,93; -0,02; -2,51; 0,91; 1,11\}\right\}</span>. From left to right we represent at time <span class="math inline">t=1, 2, 3, 4,</span> and <span class="math inline">5</span> the parameter space <span class="math inline">(\theta^1, \theta^2).</span> Each <span class="math inline">Z^i_t</span> is represented by a color. The change <span class="math inline">1</span> associated with quadratics <span class="math inline">2</span> is pruned at <span class="math inline">t = 3</span>. Notice that each time sequence of <span class="math inline">Z^i_t</span> with <span class="math inline">i</span> fixed is a nested sequence of sets.</figcaption>
</figure>
</div>
</section>
<section id="sec-geometry" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-geometry"><span class="header-section-number">2.3</span> Geometric Formulation of Functional Pruning</h2>
<p>To build an efficient pruning strategy for dimension <span class="math inline">p\ge2</span> we need to test the emptiness of the sets <span class="math inline">Z^i_t</span> at each iteration. Note that to get <span class="math inline">Z_t^i</span> we need to compare the functional cost <span class="math inline">q^i_t</span> with any other functional cost <span class="math inline">q^j_{t}</span>, <span class="math inline">j=1,\dots, t,\, j\neq i</span>. This leads to the definition of the following sets.</p>
<div id="def-defS" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (S-type set) </strong></span>We define <span class="math inline">S</span>-type set <span class="math inline">S^i_j</span> using the function <span class="math inline">\Omega</span> as <span class="math display">
S_j^i = \left\{ \theta \in \mathbb{R}^p \,|\, \sum_{u=i+1}^j \Omega(\theta, y_u) \le m_{j}-m_{i}\right\}\,,\hbox{ when } i &lt; j
</span> and <span class="math inline">S_i^i = \mathbb R^p</span>. We denote the set of all possible S-type sets as <span class="math inline">\mathbf{S}</span>.</p>
<p>To ease some of our calculations, we now introduce some additional notations. For <span class="math inline">\theta = (\theta^1,\dots,\theta^p) \in \mathbb{R}^p</span>, <span class="math inline">1 \le i &lt; j \le n</span> we define <span class="math inline">p</span> univariate functions <span class="math inline">\theta^k \mapsto s^k_{ij}(\theta^k)</span> associated to the <span class="math inline">k</span>-th time series as <span id="eq-setS"><span class="math display">
    \begin{aligned}
       &amp;s^k_{ij}(\theta^k) &amp; =&amp;\sum_{u = i+1}^{j} \omega(\theta^k,y_u^k), \quad  k = 1,\dots,p\,.
    \end{aligned}
\tag{10}</span></span> We introduce a constant <span class="math inline">\Delta_{ij}</span> and a function <span class="math inline">\theta \mapsto s_{ij}(\theta)</span>: <span id="eq-setSfunc"><span class="math display">
    \left\{
    \begin{aligned}
       \Delta_{ij} &amp; =  \,m_j - m_{i}\,,\\
       s_{ij}(\theta) &amp; =  \sum_{k=1}^p s^k_{ij}(\theta^k)- \Delta_{ij}\,,
    \end{aligned}
    \right.
\tag{11}</span></span> where <span class="math inline">m_{i}</span> and <span class="math inline">m_j</span> are defined as in <a href="#eq-m_im1" class="quarto-xref">Equation&nbsp;7</a>. The sets <span class="math inline">S_j^i</span> for <span class="math inline">i &lt; j</span> are also described by relation <span id="eq-setS"><span class="math display">
    \begin{gathered}
        S_j^i = s_{ij}^{-1} (-\infty,0]\,.
    \end{gathered}
\tag{12}</span></span> In <a href="#fig-Figure2" class="quarto-xref">Figure&nbsp;2</a> we present the level curves for three different parametric models given by <span class="math inline">s_{ij}^{-1} (\{w\})</span> with <span class="math inline">w</span> a real number. Each of these curves encloses an S-type set.</p>
</div>
<div id="fig-Figure2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Figure 2 Contoure of S-type sets and cost .png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Three examples of the level curves of a function <span class="math inline">s_{ij}</span> for bi-variate time series <span class="math inline">\{x,y\}</span>. We use the following simulations for univariate time series : (a) <span class="math inline">x\sim \mathcal{N}(0,1)</span>, <span class="math inline">y\sim \mathcal{N}(0,1)</span>, (b) <span class="math inline">x \sim \mathcal{P}(1)</span>, <span class="math inline">y \sim \mathcal{P}(3)</span>, (c) <span class="math inline">x\sim \mathcal{NB}(0.5,1)</span>, <span class="math inline">y\sim \mathcal{NB}(0.8, 1)</span>.</figcaption>
</figure>
</div>
<p>At time <span class="math inline">t = 1,\dots, n</span> we define the following sets associated to the last change point index <span class="math inline">i-1</span>:</p>
<p><span class="math inline">\mathtt{past}\,\mathtt{set} \,\mathcal{P}^i</span> <span id="eq-setE"><span class="math display">
        \begin{gathered}
            \mathcal{P}^i =\{S_{i}^u,\, u = 1,\dots,i-1\}\,.
        \end{gathered}
\tag{13}</span></span> <span class="math inline">\mathtt{future}\, \mathtt{set} \,\mathcal{F}^i(t)</span> <span id="eq-setI"><span class="math display">
        \begin{gathered}
            \mathcal{F}^i(t) =\{S_{v}^i, \, v = i,\dots,t\}\,.
        \end{gathered}
\tag{14}</span></span> We denote the cardinal of a set <span class="math inline">\mathcal{A}</span> as <span class="math inline">|\mathcal{A}|</span>. Using these two sets of sets, the <span class="math inline">Z^i_t</span> have the following description.</p>
<div id="prp-proposition_sets" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 </strong></span>At iteration <span class="math inline">t</span>, the functional cost <span class="math inline">Q_t(\cdot)</span> defines the subsets <span class="math inline">Z_t^i</span> (<span class="math inline">i=1,\dots, t</span>), each of them being the intersection of the sets in <span class="math inline">\mathcal{F}^i(t)</span> minus the union of the sets in <span class="math inline">\mathcal{P}^i</span>. <span id="eq-setsZ"><span class="math display">
    \begin{gathered}
        Z_t^i = (\cap_{S\in \mathcal{F}^i(t)}S) \setminus (\cup_{S\in \mathcal{P}^i}S)\,,\quad i = 1,\dots,t.
    \end{gathered}
\tag{15}</span></span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Based on the definition of the set <span class="math inline">Z_t^i</span>, the proof is straightforward. Parameter value <span class="math inline">\theta</span> is in <span class="math inline">Z_t^i</span> if and only if <span class="math inline">q_t^i(\theta) \le q_t^u(\theta)</span> for all <span class="math inline">u \ne i</span>; these inequalities define the past set (when <span class="math inline">u &lt; i</span>) and the future set (when <span class="math inline">u&gt;i</span>). Notice that, in case <span class="math inline">i = t</span>, <span class="math inline">\cap_{S\in \mathcal{F}^i(t)}S = \mathbb R^p</span>.</p>
</div>
<div id="cor-col1" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 </strong></span>The sequence <span class="math inline">\zeta^i = (Z_t^i)_{t\ge i}</span> is a nested sequence of sets.</p>
</div>
<p>Indeed, <span class="math inline">Z_{t+1}^i</span> is equal to <span class="math inline">Z_t^i</span> with an additional intersection in the future set. Based on <a href="#cor-col1" class="quarto-xref">Corollary&nbsp;1</a>, as soon as we prove that the set <span class="math inline">Z_t^i</span>, is empty, we delete its associated <span class="math inline">q_t^i</span> function and, consequently, we can prune the change point <span class="math inline">i-1</span>. In this context, functional and inequality-based pruning have a simple geometric interpretation.</p>
<p><em>Functional pruning geometry.</em> The position <span class="math inline">i-1</span> is pruned at step <span class="math inline">t+1</span>, in <span class="math inline">Q_{t+1}(\cdot),</span> if the intersection set of <span class="math inline">\cap_{S\in \mathcal{F}^i(t)}S</span> is covered by the union set <span class="math inline">\cup_{S\in \mathcal{P}^i}S</span>.</p>
<p><em>Inequality-based pruning geometry.</em> The inequality-based pruning of PELT is equivalent to the geometric rule: position <span class="math inline">i-1</span> is pruned at step <span class="math inline">t+1</span> if the set <span class="math inline">S_t^i</span> is empty. In that case, the intersection set <span class="math inline">\cap_{S\in \mathcal{F}^i(t)}S</span> is empty, and therefore <span class="math inline">Z_t^i</span> is also empty using <a href="#eq-setsZ" class="quarto-xref">Equation&nbsp;15</a>. This shows that if a change is pruned using inequality-based pruning it is also pruned using functional pruning. For the dimension <span class="math inline">p =1</span> this claim was theoretically proved in <span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span>.</p>
<p>The construction of set <span class="math inline">Z^i_t</span> using <a href="#prp-proposition_sets" class="quarto-xref">Proposition&nbsp;1</a> is illustrated in <a href="#fig-Figure3" class="quarto-xref">Figure&nbsp;3</a> for a bi-variate independent Gaussian case: we have the intersection of three S-type sets and the subtraction of three S-type sets.</p>
<div id="fig-Figure3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><embed src="images/Figure 3 Bilding Z with 3 past and 3 future disks set_seed_21.pdf" class="img-fluid"></p>
<figcaption class="figure-caption">Figure&nbsp;3: Examples of building a set <span class="math inline">Z^i_t</span> with <span class="math inline">\lvert\mathcal{P}^i\rvert = \lvert\mathcal{F}^i(t)\rvert = 3</span> for the Gaussian case in 2-D (<span class="math inline">\mu = 0,\sigma=1</span>). The green disks are S-type sets of the past set <span class="math inline">\mathcal{P}^i</span>. The blue disks are S-type sets of the future set <span class="math inline">\mathcal{F}^i(t)</span>.</figcaption>
</figure>
</div>
</section>
</section>
<section id="sec-GeomFPOP" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Geometric Functional Pruning Optimal Partitioning</h1>
<section id="sec-principle" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-principle"><span class="header-section-number">3.1</span> General Principle of GeomFPOP</h2>
<p>Rather than considering an exact representation of the <span class="math inline">Z^i_t</span>, our idea is to consider a hopefully slightly larger set that is easier to update. To be specific for each <span class="math inline">Z^i_t</span> we introduce <span class="math inline">\tilde{Z}^i_t</span>, called <em>testing set</em>, such that <span class="math inline">Z^i_t\subset \tilde{Z}^i_t</span>. If at time <span class="math inline">t</span> <span class="math inline">\tilde{Z}^i_t</span> is empty thus is <span class="math inline">Z^i_t</span> and thus change <span class="math inline">i-1</span> can be pruned. From proposition we have that starting from <span class="math inline">Z = \mathbb{R}^p</span> the set <span class="math inline">Z^i_t</span> is obtained by successively applying two types of operations: intersection with an S-type set <span class="math inline">S</span> <span class="math inline">(Z\cap S)</span> or subtraction of an S-type set <span class="math inline">S</span> <span class="math inline">(Z\setminus S)</span>. Similarly, starting from <span class="math inline">\tilde{Z} = \mathbb{R}^p</span> we obtain <span class="math inline">\tilde{Z}^i_t</span> by successively applying approximation of these intersection and subtraction operations. Intuitively, the complexity of the resulting algorithm is a combination of the efficiency of the pruning and the easiness of updating the testing set.</p>
<p><em>A Generic Formulation of GeomFPOP.</em> In what follows we will generically describe GeomFPOP, that is without specifying the precise structure of the testing set <span class="math inline">\tilde{Z}^i_t</span>. We call <span class="math inline">\mathbf{\tilde{Z}}</span> the set of all possible <span class="math inline">\tilde{Z}^i_t</span> and assume the existence of two operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span>. We have the following assumptions for these operators.</p>
<div id="def-assumption1" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2 </strong></span>The two operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span> are such that:</p>
<ol type="1">
<li>the left input is a <span class="math inline">\tilde{Z}</span>-type set (that is an element of <span class="math inline">\tilde{\mathbf{Z}}</span>);</li>
<li>the right input is a <span class="math inline">S</span>-type set;</li>
<li>the output is a <span class="math inline">\tilde{Z}</span>-type set;</li>
<li><span class="math inline">\tilde{Z} \cap S \subset \tilde{Z} \cap_{\tilde{Z}} S</span> and <span class="math inline">\tilde{Z} \setminus S \subset \tilde{Z} \setminus_{\tilde{Z}} S</span>.</li>
</ol>
</div>
<p>We give a proper description of two types of testing sets and their approximation operators in <a href="#sec-approximation" class="quarto-xref">Section&nbsp;4</a>.</p>
<p>At each iteration <span class="math inline">t</span> GeomFPOP will construct <span class="math inline">\tilde{Z}^i_{t+1}</span> from <span class="math inline">\tilde{Z}^i_{t}</span>, <span class="math inline">\mathcal{P}^i</span> and, <span class="math inline">\mathcal{F}^i(t)</span> iteratively using the two operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span>. To be specific, we define <span class="math inline">S_j^F</span> the j-th element of <span class="math inline">\mathcal{F}^i(t)</span> and <span class="math inline">S_P^j</span> the j-th element of <span class="math inline">\mathcal{P}^i</span>, we use the following iteration: <span class="math display">
    \left\{
      \begin{aligned}
       A_{0} =\tilde{Z}^i_{t} \,, &amp; \quad A_j = A_{j-1}\,\cap_{\tilde{Z}}\, S_j^F\,, &amp; j = 1,\dots , |\mathcal{F}^i(t)|\,,\\
        B_{0} =A_{|\mathcal{F}^i(t)|}\,, &amp; \quad B_j = B_{j-1}\,\setminus_{\tilde{Z}} \, S_P^j\,, &amp; j = 1,\dots , |\mathcal{P}^i| \,,\\
    \end{aligned}  
    \right.
</span> and define <span class="math inline">\tilde{Z}^i_{t+1} = B_{|\mathcal{P}^i|}.</span> Using the fourth property of <a href="#def-assumption1" class="quarto-xref">Definition&nbsp;2</a> and <a href="#prp-proposition_sets" class="quarto-xref">Proposition&nbsp;1</a>, we get that at any time of the algorithm <span class="math inline">\tilde{Z}^i_t</span> contains <span class="math inline">{Z}^i_t.</span></p>
<p>The pseudo-code of this procedure is described in <a href="#fig-alg1" class="quarto-xref">Figure&nbsp;4</a>. The <span class="math inline">\mathtt{select}(\mathcal{A})</span> step in <a href="#fig-alg1" class="quarto-xref">Figure&nbsp;4</a>, where <span class="math inline">\mathcal{A} \subset \mathbf S</span>, returns a subset of <span class="math inline">\mathcal{A}</span> in <span class="math inline">\mathbf S</span>. By default, <span class="math inline">\mathtt{select}(\mathcal{A}) := \mathcal{A}</span>.</p>
<div id="fig-alg1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/alg1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4: Geometric update rule of <span class="math inline">\tilde{Z}^i_t</span></figcaption>
</figure>
</div>
<p>We denote the set of change points candidates at time <span class="math inline">t</span> as <span class="math inline">\tau_t</span>. Note that for any <span class="math inline">(i-1)\in \tau_t</span> the sum of <span class="math inline">|\mathcal P^i|</span> and <span class="math inline">|\mathcal F^i(t)|</span> is <span class="math inline">|\tau_t|</span>. With the default <span class="math inline">\mathtt{select}()</span> procedure we do <span class="math inline">\mathcal{O}(p|\tau_t|)</span> operations in <a href="#fig-alg1" class="quarto-xref">Figure&nbsp;4</a>. By limiting the number of elements returned by <span class="math inline">\mathtt{select}()</span> we can reduce the complexity.</p>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>For example, if the operator <span class="math inline">\mathcal{A} \mapsto \mathtt{select}(\mathcal{A})</span>, regardless of <span class="math inline">|\mathcal A|</span>, always returns a subset of constant size, then the overall complexity of GeomFPOP is at worst equal to that of PELT with <span class="math inline">\sum_{t=1}^{n}\mathcal{O}(p|\tau_t|)</span> time complexity.</p>
</div>
<p>Using this <span class="math inline">\mathtt{updateZone}()</span> procedure we can now informally describe the GeomFPOP algorithm. At each iteration the algorithm will</p>
<ol type="1">
<li>find the minimum value for <span class="math inline">Q_t</span>, <span class="math inline">m_t</span>; and the best position for last change point <span class="math inline">\hat \tau_t</span> (note that this step is standard: as in the PELT algorithm we need to minimize the cost of the last segment defined in <a href="#eq-Cy_it" class="quarto-xref">Equation&nbsp;1</a>);</li>
<li>compute all sets <span class="math inline">\tilde{Z}_{t}^{i}</span> using <span class="math inline">\tilde{Z}_{t+1}^{i}</span>, <span class="math inline">\mathcal{P}^i</span>, and <span class="math inline">\mathcal{F}^i(t)</span> with the <span class="math inline">\mathtt{updateZone}()</span> procedure;</li>
<li>remove changes such that <span class="math inline">\tilde{Z}_{t+1}^{i}</span> is empty.</li>
</ol>
<p>To simplify the pseudo-code of GeomFPOP, we also define the following operators:</p>
<ol type="1">
<li><span class="math inline">\mathtt{bestCost\&amp;Tau}(t)</span> operator returns two values: the minimum value of <span class="math inline">Q_t</span>, <span class="math inline">m_t</span>, and the best position for last change point <span class="math inline">\hat \tau_t</span> at time <span class="math inline">t</span> (see {sec-UpdateRule);</li>
<li><span class="math inline">\mathtt{getPastFutureSets}(i,t)</span> operator returns a pair of sets (<span class="math inline">\mathcal{F}^i(t)</span>, <span class="math inline">\mathcal{P}^i</span>) for change point candidate <span class="math inline">i-1</span> at time <span class="math inline">t</span>;</li>
<li><span class="math inline">\mathtt{backtracking}(\hat\tau, n)</span> operator returns the optimal segmentation for <span class="math inline">y_{1:n}</span>.</li>
</ol>
<p>The pseudo-code of GeomFPOP is presented in <a href="#fig-alg2" class="quarto-xref">Figure&nbsp;5</a>.</p>
<div id="fig-alg2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/alg2.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5: GeomFPOP algorithm</figcaption>
</figure>
</div>
</section>
</section>
<section id="sec-approximation" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Approximation Operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span></h1>
<p>The choice of the geometric structure and the way it is constructed directly affects the computational cost of the algorithm. We consider two types of testing set <span class="math inline">\tilde{Z} \in \mathbf{\tilde{Z}}</span>, a S-type set <span class="math inline">\tilde{S}\in \mathbf{S}</span> (see <a href="#def-defS" class="quarto-xref">Definition&nbsp;1</a>) and a hyperrectangle <span class="math inline">\tilde{R}\in \mathbf{R}</span> defined below.</p>
<div id="def-Hyperrectangle" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3 (Hyperrectangle) </strong></span>Given two vectors in <span class="math inline">\mathbb{R}^p</span>, <span class="math inline">\tilde{l}</span> and <span class="math inline">\tilde{r}</span> we define the set <span class="math inline">\tilde{R}</span>, called <em>hyperrectangle</em>, as: <span id="eq-setR"><span class="math display">
            \tilde{R} = [\tilde{l}_1,\tilde{r}_1]\times \dots \times[\tilde{l}_p,\tilde{r}_p]\,. \\
\tag{16}</span></span> We denote the set of all possible sets <span class="math inline">\tilde{R}</span> as <span class="math inline">\mathbf{R}</span>.</p>
</div>
<p>To update the testing sets we need to give the strict definition of the operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span> for each type of testing set. To facilitate the following discussion, we rename them. For the first type of geometric structure, we rename the testing set <span class="math inline">\tilde{Z}</span> as <span class="math inline">\tilde{S}</span>, the operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span> as <span class="math inline">\cap_{S}</span> and <span class="math inline">\setminus_{S}</span> and <span class="math inline">\tilde{Z}</span>-type approximation as S-type approximation. And, likewise, we rename the testing set <span class="math inline">\tilde{Z}</span> as <span class="math inline">\tilde{R}</span>, the operators <span class="math inline">\cap_{\tilde{Z}}</span> and <span class="math inline">\setminus_{\tilde{Z}}</span> as <span class="math inline">\cap_{R}</span> and <span class="math inline">\setminus_{R}</span> and <span class="math inline">\tilde{Z}</span>-type approximation as R-type approximation for the second type of geometric structure.</p>
<section id="s-type-approximation" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="s-type-approximation"><span class="header-section-number">4.1</span> S-type Approximation</h2>
<p>With this approach, our goal is to keep track of the fact that at time <span class="math inline">t = 1,\dots, n</span> there is a pair of changes <span class="math inline">(u_1,u_2)</span>, with <span class="math inline">u_1 &lt; i &lt; u_2\le t</span> such that <span class="math inline">S^i_{u_2}\subset S^{u_1}_{i}</span> or there is a pair of changes <span class="math inline">(v_1,v_2)</span>, with <span class="math inline">i &lt; v_1 &lt; v_2\le t</span> such that <span class="math inline">S^i_{v_1}\cap S^i_{v_2}</span> is empty. If at time <span class="math inline">t</span> at least one of these conditions is met, we can guarantee that the set <span class="math inline">\tilde{S}</span> is empty, otherwise, we propose to keep as the result of approximation the last future S-type set <span class="math inline">S^i_t</span>, because it always includes the set <span class="math inline">Z^i_t</span>. This allows us to quickly check and prove (if <span class="math inline">\tilde{S} =\emptyset</span>) the emptiness of set <span class="math inline">Z^i_t</span>.</p>
<p>We consider two generic S-type sets, <span class="math inline">S</span> and <span class="math inline">\tilde{S}</span> from <span class="math inline">\mathbf{S}</span>, described as in <a href="#eq-setS" class="quarto-xref">Equation&nbsp;12</a> by the functions <span class="math inline">s</span> and <span class="math inline">\tilde{s}</span>: <span id="eq-setSStilde"><span class="math display">
         s(\theta) = \sum_{k=1}^p s^k(\theta^k)- \Delta\,,\quad\quad
        \tilde{s}(\theta) = \sum_{k=1}^p {\tilde{s}}^{k}(\theta^k)- \tilde{\Delta}\,.
\tag{17}</span></span></p>
<div id="def-def_oper_S" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4 </strong></span>For all <span class="math inline">S</span> and <span class="math inline">\tilde{S}</span> in <span class="math inline">\mathbf{S}</span> we define the operators <span class="math inline">\cap_{S}</span> and <span class="math inline">\setminus_{S}</span> as:</p>
<p><span id="eq-Zempty"><span class="math display">
    \begin{aligned}
        &amp;\tilde{S}\, \cap_{S}\, S&amp; = \left\{
        \begin{aligned}
            &amp; \emptyset \,,  &amp; \hbox{ if }  \tilde{S}\cap S = \emptyset \,,\\
            &amp; \tilde{S}\,, &amp; \hbox{otherwise}\,.\\
        \end{aligned}
        \right.\\
         &amp;\tilde{S} \,\setminus_{S}\, S   &amp; = \left\{
        \begin{aligned}
        &amp; \emptyset \,,  &amp; \hbox{ if }  \tilde{S} \subset S\,,\\
        &amp; \tilde{S}\,, &amp; \hbox{otherwise}\,.\\
        \end{aligned}
        \right.
    \end{aligned}
\tag{18}</span></span></p>
</div>
<p>As a consequence, we only need an easy way to detect any of these two geometric configurations: <span class="math inline">\tilde{S}\cap S</span> and <span class="math inline">\tilde{S} \subset S</span>.</p>
<p>In the Gaussian case, the S-type sets are <span class="math inline">p</span>-balls and an easy solution exists based on comparing radii (see <strong>?@sec-InterandExclBalls</strong> for details). In the case of other models (as Poisson or negative binomial), intersection and inclusion tests are performed through an iterative algorithm solving convex problems (see <span class="citation" data-cites="append:IntersectionSsets">(<a href="#ref-append:IntersectionSsets" role="doc-biblioref"><strong>append:IntersectionSsets?</strong></a>)</span>). This iterative approach is not constant in time, which is why we also considered another type of testing set.</p>
</section>
<section id="r-type-approximation" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="r-type-approximation"><span class="header-section-number">4.2</span> R-type Approximation</h2>
<p>Here, we approximate the sets <span class="math inline">Z^i_t</span> by hyperrectangles <span class="math inline">\tilde{R}^i_t \in \mathbf{R}</span>. A key insight of this approximation is that given a hyperrectangle <span class="math inline">R</span> and an S-type set <span class="math inline">S</span> we can efficiently (in <span class="math inline">\mathcal{O}(p)</span> using <a href="#prp-prop_solution_rect" class="quarto-xref">Proposition&nbsp;3</a>) recover the best hyperrectangle approximation of <span class="math inline">R \cup S</span> and <span class="math inline">R \setminus S.</span> Formally we define these operators as follows.</p>
<div id="def-operR" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 5 (Hyperrectangles Operators <span class="math inline">\cap_{R}</span>, <span class="math inline">\setminus_{R}</span> )) </strong></span>For all <span class="math inline">R, \tilde{R} \in \mathbf{R}</span> and <span class="math inline">S\in \mathbf{S}</span> we define the operators <span class="math inline">\cap_{R}</span> and <span class="math inline">\setminus_{R}</span> as: <span class="math display">
    \begin{aligned}
     R \cap_{R} S = \cap_{\{\tilde{R} | R \cap S \subset \mathbf{R}\}} \tilde{R}\,,\\
      R \setminus_{R} S = \cap_{\{\tilde{R} | R \setminus S \subset \mathbf{R}\}} \tilde{R}\,.
\end{aligned}
</span></p>
</div>
<p>We now explain how we compute these two operators. First, we note that they can be recovered by solving a <span class="math inline">2p</span> one-dimensional optimization problem.</p>
<div id="prp-proposition" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2 </strong></span>The <span class="math inline">k</span>-th minimum coordinates <span class="math inline">\tilde{l}_k</span> and maximum coordinates <span class="math inline">\tilde{r}_k</span> of <span class="math inline">\tilde{R} = R \cap_{R} S</span> (resp. <span class="math inline">\tilde{R} = R \setminus_{R} S</span>) is obtained as <span id="eq-inclusionOptim"><span class="math display">
    \tilde{l}_k \hbox{ or } \tilde{r}_k =
    \left\{
    \begin{aligned}
        &amp;\min_{\theta_k \in \mathbb{R}} \hbox{ or } \max_{\theta_k \in \mathbb{R}}  \theta_k\,,\\
        &amp; \hbox{subject to } \varepsilon s(\theta) \le 0 \,,\\
        &amp; \quad \quad \quad \quad \quad l_j \le \theta_j \le r_j\,,\quad j = 1,\dots,p \,,\\
    \end{aligned}
    \right.  
\tag{19}</span></span> with <span class="math inline">\varepsilon = 1</span> (resp. <span class="math inline">\varepsilon = -1</span>).</p>
</div>
<p>To solve the previous problems (<span class="math inline">\varepsilon = 1</span> or <span class="math inline">-1</span>), we define the following characteristic points.</p>
<div id="def-points" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 6 (Minimal, closest and farthest points) </strong></span>Let <span class="math inline">S \in \mathbf{S}</span>, described by function <span class="math inline">s(\theta) = \sum_{k=1}^{p} s^k(\theta^k) - \Delta</span> from the family of functions (<a href="#eq-setSfunc" class="quarto-xref">Equation&nbsp;11</a>), with <span class="math inline">\theta\in \mathbb{R}^p</span>. We define the minimal point <span class="math inline">\mathbf{c}\in \mathbb{R}^p</span> of <span class="math inline">S</span> as: <span id="eq-c"><span class="math display">
    \mathbf{c} = \left\{\mathbf{c}^k\right\}_{k=1,\dots,p}, \quad \text { with }\quad \mathbf{c}^k =\underset{\theta^k \in \mathbb R} Arg\min \{ s^k(\theta^k) \}\,.
\tag{20}</span></span> Moreover, with <span class="math inline">R \in \mathbf{R}</span> defined through vectors <span class="math inline">l,r \in \mathbb{R}^p</span>, we define two points of <span class="math inline">R</span>, the closest point <span class="math inline">\mathbf{m} \in \mathbb{R}^p</span> and the farthest point <span class="math inline">\mathbf{M} \in \mathbb{R}^p</span> relative to <span class="math inline">S</span> as <span id="eq-mk"><span class="math display">
\begin{aligned}
    \mathbf{m} =\left\{\mathbf{m}^k\right\}_{k=1,\dots,p},\quad \text { with }\quad
    \mathbf{m}^k = \underset{l^k \le \theta^k \le r^k}{Arg\min}  \left\{ s^k(\theta^k)\right\},\\
    \mathbf{M} =\left\{\mathbf{M}^k\right\}_{k=1,\dots,p},\quad \text { with }\quad
    \mathbf{M}^k = \underset{l^k \le \theta^k \le r^k}{Arg\max}  \left\{s^k(\theta^k)\right\}\,.
    \end{aligned}
\tag{21}</span></span></p>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>In the Gaussian case, <span class="math inline">S</span> is a ball in <span class="math inline">\mathbb{R}^p</span> and</p>
<ul>
<li><span class="math inline">\mathbf{c}</span> is the center of the ball;</li>
<li><span class="math inline">\mathbf{m}</span> is the closest point to <span class="math inline">\mathbf{c}</span> inside <span class="math inline">R</span>;</li>
<li><span class="math inline">\mathbf{M}</span> is the farthest point to <span class="math inline">\mathbf{c}</span> in <span class="math inline">R</span>.</li>
</ul>
</div>
<div id="fig-Figure4" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Figure 4 Minimal closest and farthest points.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;6: Three examples of minimal point <span class="math inline">\mathbf{c}</span>, closest point <span class="math inline">\mathbf{m}</span> and farthest point <span class="math inline">\mathbf{M}</span> for bi-variate Gaussian case: (a) <span class="math inline">R \subset S</span>; (b) <span class="math inline">R \cap S \neq \emptyset</span>; (c) <span class="math inline">R \cap S = \emptyset</span>.</figcaption>
</figure>
</div>
<div id="prp-prop_solution_rect" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3 </strong></span>Let <span class="math inline">\tilde{R} = R \cap_{R} S</span> (resp. <span class="math inline">R\setminus_{R} S</span>), with <span class="math inline">R \in \mathbf{R}</span> and <span class="math inline">S \in \mathbf{S}</span>. We compute the boundaries <span class="math inline">(\tilde{l}, \tilde{r})</span> of <span class="math inline">\tilde{R}</span> using the following rule:</p>
<ol type="i">
<li>We define the point <span class="math inline">\tilde{\theta}\in \mathbb{R}^p</span> as the closest point <span class="math inline">\mathbf{m}</span> (resp. farthest <span class="math inline">\mathbf{M}</span>). For all <span class="math inline">k = 1,\dots p</span> we find the roots <span class="math inline">\theta^{k_1}</span> and <span class="math inline">\theta^{k_2}</span> of the one-variable <span class="math inline">(\theta^k)</span> equation <span id="eq-eqs_k"><span class="math display">
s^k(\theta^k)+\sum_{j\neq k} s^j(\tilde{\theta}^j) -\Delta= 0 \,.
\tag{22}</span></span> If the roots are real-valued we consider that <span class="math inline">\theta^{k_1} \le \theta^{k_2}</span>, otherwise we write <span class="math inline">\Big[\theta^{k_1},\theta^{k_2}\Big] = \emptyset</span>.</li>
<li>We compute the boundary values <span class="math inline">\tilde{l}^k</span> and <span class="math inline">\tilde{r}^k</span> of <span class="math inline">\tilde{R}</span> as:</li>
</ol>
<ul>
<li>For <span class="math inline">R\cap_{R} S</span> <span class="math inline">(k = 1,\dots,p)</span>: <span id="eq-updateIntersection"><span class="math display">
\Big[\tilde{l}^k,\tilde{r}^k\Big] = \Big[\theta^{k_1},\theta^{k_2}\Big] \cap \Big[l^k, r^k\Big]\,.
\tag{23}</span></span></li>
<li>For <span class="math inline">R\setminus_{R} S</span> <span class="math inline">(k = 1,\dots,p)</span>: <span class="math display">
\Big[\tilde{l}^k,\tilde{r}^k\Big] =
\left\{
\begin{aligned}
&amp; \Big[l^k, r^k\Big]  \setminus \Big[\theta^{k_1},\theta^{k_2}\Big] \,,  &amp; \hbox{if} \quad \Big[\theta^{k_1},\theta^{k_2}\Big] \not\subset \Big[l^k, r^k\Big]\,,\\
&amp; \Big[l^k, r^k\Big]\,, &amp; \hbox{otherwise}\,.\\
\end{aligned}
\right.
</span> If there is a dimension <span class="math inline">k</span> for which <span class="math inline">\Big[\tilde{l}^k, \tilde{r}^k\Big]=\emptyset</span>, then the set <span class="math inline">\tilde{R}</span> is empty.</li>
</ul>
</div>
<p>The proof of <a href="#prp-prop_solution_rect" class="quarto-xref">Proposition&nbsp;3</a> is presented in <strong>?@sec-proof_prop_solution_rect</strong>.</p>
</section>
</section>
<section id="sec-study" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Simulation Study of GeomFPOP</h1>
<p>In this section, we study the efficiency of GeomFPOP using simulations of multivariate independent time series. For this, we implemented GeomFPOP (with S and R types) and PELT for the Multivariate Independent Gaussian Model in the R-package ‘GeomFPOP’ <a href="https://github.com/lpishchagina/GeomFPOP">https://github.com/lpishchagina/GeomFPOP</a> written in R/C++. By default, the value of penalty <span class="math inline">\beta</span> for each simulation was defined by the Schwarz Information Criterion proposed in <span class="citation" data-cites="Yao">Yao (<a href="#ref-Yao" role="doc-biblioref">1984</a>)</span> (<span class="math inline">\beta = 2p \log{n}</span>).</p>
<p><em>Overview of our simulations.</em> First, as a quality control we made sure that the output of PELT and GeomFPOP were identical on a number of simulated profiles. Second, we studied cases where the PELT approach is not efficient, that is when the data has no or few changes relative to <span class="math inline">n</span>. Indeed, it was shown in <span class="citation" data-cites="Killick">Killick, Fearnhead, and Eckley (<a href="#ref-Killick" role="doc-biblioref">2012</a>)</span> and <span class="citation" data-cites="Maidstone">Maidstone et al. (<a href="#ref-Maidstone" role="doc-biblioref">2017</a>)</span> that the run time of PELT is close to <span class="math inline">\mathcal{O}(n^2)</span> in such cases. So we considered simulations of multivariate time series without change (only one segment). By these simulations we evaluated the pruning efficiency of GeomFPOP (using S and R types) for dimension <span class="math inline">2\le p\le 10</span> (see <strong>?@fig-Figure5</strong> in <strong>?@sec-NC</strong>). For small dimensions (<span class="math inline">2 \le p \le 4</span>) we also evaluated the run time of GeomFPOP and PELT and compare them (see <strong>?@fig-Figure6</strong> in <strong>?@sec-TCsmall</strong>). In addition, we considered another approximation of the <span class="math inline">Z^i_t</span> where we applied our <span class="math inline">\cap_{R}</span> and <span class="math inline">\setminus_R</span> operators only for a randomly selected subset of the past and future balls. In practice, this strategy turned out to be faster computationally than the full/original GeomFPOP and PELT (see <strong>?@fig-Figure7</strong> in <strong>?@sec-GeomFPOP_random</strong>). For this strategy we also generated time series of a fixed size (<span class="math inline">10^6</span> data points) and varying number of segments and evaluated how the run time vary with the number of segments for small dimensions (<span class="math inline">2 \le p \le 4</span>). Our empirical results confirmed that the GeomFPOP (R-type: <span class="math inline">\mathtt{random/random}</span>) approach is computationally comparable to PELT when the number of changes is large (see <strong>?@fig-Figure9</strong> in <strong>?@sec-Run_time_segment_nb</strong>).</p>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-aminikhanghahi2017survey" class="csl-entry" role="listitem">
Aminikhanghahi, Samaneh, and Diane J Cook. 2017. <span>“A Survey of Methods for Time Series Change Point Detection.”</span> <em>Knowledge and Information Systems</em> 51 (2): 339–67.
</div>
<div id="ref-fryzlewicz2020detecting" class="csl-entry" role="listitem">
Anastasiou, Andreas, and Piotr Fryzlewicz. 2022. <span>“Detecting Multiple Generalized Change-Points by Isolating Single Ones.”</span> <em>Metrika</em> 85 (February). <a href="https://doi.org/10.1007/s00184-021-00821-6">https://doi.org/10.1007/s00184-021-00821-6</a>.
</div>
<div id="ref-Andreou" class="csl-entry" role="listitem">
Andreou, Elena, and Eric Ghysels. 2002. <span>“Detecting Multiple Breaks in Financial Market Volatility Dynamics.”</span> <em>Journal of Applied Econometrics</em> 17 (5): 579–600. <a href="http://www.jstor.org/stable/4129273">http://www.jstor.org/stable/4129273</a>.
</div>
<div id="ref-Aue_monitoring" class="csl-entry" role="listitem">
Aue, Alexander, Lajos Horváth, Marie Hušková, and Piotr Kokoszka. 2006. <span>“Change-Point Monitoring in Linear Models.”</span> <em>The Econometrics Journal</em> 9 (3): 373–403. <a href="http://www.jstor.org/stable/23114925">http://www.jstor.org/stable/23114925</a>.
</div>
<div id="ref-Auger" class="csl-entry" role="listitem">
Auger, Ivan E., and Charles E. Lawrence. 1989. <span>“Algorithms for the Optimal Identification of Segment Neighborhoods.”</span> <em>Bulletin of Mathematical Biology</em> 51 (1): 39–54. <a href="https://doi.org/10.1007/BF02458835">https://doi.org/10.1007/BF02458835</a>.
</div>
<div id="ref-bai2003computation" class="csl-entry" role="listitem">
Bai, Jushan, and Pierre Perron. 2003. <span>“Computation and Analysis of Multiple Structural-Change.”</span> <em>Journal of Applied Econometrics</em> 18 (January).
</div>
<div id="ref-Bosc2003" class="csl-entry" role="listitem">
Bosc, Marcel, Fabrice Heitz, Jean-Paul Armspach, Izzie Namer, Daniel Gounot, and Lucien Rumbach. 2003. <span>“Automatic Change Detection in Multimodal Serial MRI: Application to Multiple Sclerosis Lesion Evolution.”</span> <em>NeuroImage 20(2)</em>, 643–56. https://doi.org/<a href="https://doi.org/10.1016/S1053-8119(03)00406-3">https://doi.org/10.1016/S1053-8119(03)00406-3</a>.
</div>
<div id="ref-NRCreport2013" class="csl-entry" role="listitem">
Data, Committee, Committee Statistics, Board Applications, Division Sciences, and National Council. 2013. <em>Frontiers in Massive Data Analysis</em>. <em>Frontiers in Massive Data Analysis</em>. <a href="https://doi.org/10.17226/18374">https://doi.org/10.17226/18374</a>.
</div>
<div id="ref-Davis2006" class="csl-entry" role="listitem">
Davis, Richard A., Thomas C. M. Lee, and Gabriel A. Rodriguez-Yam. 2006. <span>“Structural Break Estimation for Nonstationary Time Series Models.”</span> <em>Journal of the American Statistical Association</em> 101: 223–39. <a href="https://EconPapers.repec.org/RePEc:bes:jnlasa:v:101:y:2006:p:223-239">https://EconPapers.repec.org/RePEc:bes:jnlasa:v:101:y:2006:p:223-239</a>.
</div>
<div id="ref-DucrRobitaille2003" class="csl-entry" role="listitem">
Ducré-Robitaille, Jean-François, Lucie A. Vincent, and Gilles Boulet. 2003. <span>“Comparison of Techniques for Detection of Discontinuities in Temperature Series.”</span> <em>International Journal of Climatology</em> 23.
</div>
<div id="ref-fearnhead2018detecting" class="csl-entry" role="listitem">
Fearnhead, Paul, Robert Maidstone, and Adam Letchford. 2018. <span>“Detecting Changes in Slope with an L0 Penalty.”</span> <em>Journal of Computational and Graphical Statistics</em>, 1–11.
</div>
<div id="ref-Frick2013" class="csl-entry" role="listitem">
Frick, Klaus, Axel Munk, and Hannes Sieling. 2013. <span>“Multiscale Change-Point Inference.”</span> arXiv. <a href="https://doi.org/10.48550/ARXIV.1301.7212">https://doi.org/10.48550/ARXIV.1301.7212</a>.
</div>
<div id="ref-Fryzlewicz_2014" class="csl-entry" role="listitem">
Fryzlewicz, Piotr. 2014. <span>“Wild Binary Segmentation for Multiple Change-Point Detection.”</span> <em>The Annals of Statistics</em> 42 (6). <a href="https://doi.org/10.1214/14-aos1245">https://doi.org/10.1214/14-aos1245</a>.
</div>
<div id="ref-galceran2017multipolicy" class="csl-entry" role="listitem">
Galceran, Enric, Alexander Cunningham, Ryan Eustice, and Edwin Olson. 2017. <span>“Multipolicy Decision-Making for Autonomous Driving via Changepoint-Based Behavior Prediction: Theory and Experiment.”</span> <em>Autonomous Robots</em> 41 (August). <a href="https://doi.org/10.1007/s10514-017-9619-z">https://doi.org/10.1007/s10514-017-9619-z</a>.
</div>
<div id="ref-harchaoui2010multiple" class="csl-entry" role="listitem">
Harchaoui, Z., and C. Lévy-Leduc. 2010. <span>“Multiple Change-Point Estimation with a Total Variation Penalty.”</span> <em>Journal of the American Statistical Association</em> 105 (492): 1480–93. <a href="http://www.jstor.org/stable/27920180">http://www.jstor.org/stable/27920180</a>.
</div>
<div id="ref-jackson2005algorithm" class="csl-entry" role="listitem">
Jackson, Brad, Jeffrey D Scargle, David Barnes, Sundararajan Arabhi, Alina Alt, Peter Gioumousis, Elyus Gwin, Paungkaew Sangtrakulcharoen, Linda Tan, and Tun Tao Tsai. 2005. <span>“An Algorithm for Optimal Partitioning of Data on an Interval.”</span> <em>IEEE Signal Processing Letters</em> 12 (2): 105–8.
</div>
<div id="ref-jewell2020fast" class="csl-entry" role="listitem">
Jewell, Sean, Paul Fearnhead, and Daniela Witten. 2019. <span>“Testing for a Change in Mean After Changepoint Detection.”</span> arXiv. <a href="https://doi.org/10.48550/ARXIV.1910.04291">https://doi.org/10.48550/ARXIV.1910.04291</a>.
</div>
<div id="ref-Killick" class="csl-entry" role="listitem">
Killick, R., P. Fearnhead, and I. A. Eckley. 2012. <span>“Optimal Detection of Changepoints with a Linear Computational Cost.”</span> <em>Journal of the American Statistical Association</em> 107 (500): 1590–98.
</div>
<div id="ref-lai2005comparative" class="csl-entry" role="listitem">
Lai, Weil R, Mark D Johnson, Raju Kucherlapati, and Peter J Park. 2005. <span>“Comparative Analysis of Algorithms for Identifying Amplifications and Deletions in Array CGH Data.”</span> <em>Bioinformatics</em> 21 (19): 3763–70.
</div>
<div id="ref-lavielle2000least" class="csl-entry" role="listitem">
Lavielle, Marc, and Eric Moulines. 2000. <span>“Least-Squares Estimation of an Unknown Number of Shifts in a Time Series.”</span> <em>Journal of Time Series Analysis</em> 21 (1): 33–59.
</div>
<div id="ref-Lebarbier2005" class="csl-entry" role="listitem">
Lebarbier, Emilie. 2005. <span>“Detecting Multiple Change-Points in the Mean of Gaussian Process by Model Selection.”</span> <em>Signal Processing</em> 85 (April): 717–36. <a href="https://doi.org/10.1016/j.sigpro.2004.11.012">https://doi.org/10.1016/j.sigpro.2004.11.012</a>.
</div>
<div id="ref-liehrmann2021increased" class="csl-entry" role="listitem">
Liehrmann, Arnaud, Guillem Rigaill, and Toby Dylan Hocking. 2021. <span>“Increased Peak Detection Accuracy in over-Dispersed ChIP-Seq Data with Supervised Segmentation Models.”</span> <em>BMC Bioinformatics</em> 22 (1): 1–18.
</div>
<div id="ref-Maidstone" class="csl-entry" role="listitem">
Maidstone, Robert, Toby Hocking, Guillem Rigaill, and Paul Fearnhead. 2017. <span>“On Optimal Multiple Changepoint Algorithms for Large Data.”</span> <em>Statistics and Computing</em> 27 (2): 519–33.
</div>
<div id="ref-Malladi2013OnlineBC" class="csl-entry" role="listitem">
Malladi, Rakesh, Giridhar P. Kalamangalam, and Behnaam Aazhang. 2013. <span>“Online Bayesian Change Point Detection Algorithms for Segmentation of Epileptic Activity.”</span> <em>2013 Asilomar Conference on Signals, Systems and Computers</em>, 1833–37.
</div>
<div id="ref-Naoki2010" class="csl-entry" role="listitem">
Naoki, Itoh, and Juergen Kurths. 2010. <span>“Change-Point Detection of Climate Time Series by Nonparametric Method.”</span> <em>Lecture Notes in Engineering and Computer Science</em> 2186 (October).
</div>
<div id="ref-olshen2004circular" class="csl-entry" role="listitem">
Olshen, Adam, E. S. Venkatraman, Robert Lucito, and Michael Wigler. 2004. <span>“Circular Binary Segmentation for the Analysis of Array-Based DNA Copy Number Data.”</span> <em>Biostatistics (Oxford, England)</em> 5 (November): 557–72. <a href="https://doi.org/10.1093/biostatistics/kxh008">https://doi.org/10.1093/biostatistics/kxh008</a>.
</div>
<div id="ref-Picard2005" class="csl-entry" role="listitem">
Picard, Franck, Stephane Robin, Marc Lavielle, Christian Vaisse, and Jean-Jacques Daudin. 2005. <span>“<span class="nocase">A statistical approach for array CGH data analysis</span>.”</span> <em><span>BMC Bioinformatics</span></em> 6: np. <a href="https://doi.org/10.1186/1471-2105-6-27">https://doi.org/10.1186/1471-2105-6-27</a>.
</div>
<div id="ref-Radke" class="csl-entry" role="listitem">
Radke, R. J., S. Andra, O. Al-Kofahi, and B. Roysam. 2005. <span>“Image Change Detection Algorithms: A Systematic Survey.”</span> <em>IEEE Transactions on Image Processing</em> 14 (3): 294–307. <a href="https://doi.org/10.1109/TIP.2004.838698">https://doi.org/10.1109/TIP.2004.838698</a>.
</div>
<div id="ref-ranganathan2012pliss" class="csl-entry" role="listitem">
Ranganathan, Ananth. 2012. <span>“PLISS: Labeling Places Using Online Changepoint Detection.”</span> <em>Auton. Robots</em> 32 (4): 351–68. <a href="https://doi.org/10.1007/s10514-012-9273-4">https://doi.org/10.1007/s10514-012-9273-4</a>.
</div>
<div id="ref-Reeves2007" class="csl-entry" role="listitem">
Reeves, Jaxk, Jien Chen, Xiaolan L. Wang, Robert Lund, and Qi Qi Lu. 2007. <span>“A Review and Comparison of Changepoint Detection Techniques for Climate Data.”</span> <em>Journal of Applied Meteorology and Climatology</em> 46 (6): 900–915. <a href="https://doi.org/10.1175/JAM2493.1">https://doi.org/10.1175/JAM2493.1</a>.
</div>
<div id="ref-Rigaill2010" class="csl-entry" role="listitem">
Rigaill, Guillem. 2010. <span>“A Pruned Dynamic Programming Algorithm to Recover the Best Segmentations with <span class="math inline">1</span> to <span class="math inline">K_{max}</span> Change-Points.”</span> <a href="https://doi.org/10.48550/ARXIV.1004.0887">https://doi.org/10.48550/ARXIV.1004.0887</a>.
</div>
<div id="ref-runge2020finite" class="csl-entry" role="listitem">
Runge, Vincent. 2020. <span>“Is a Finite Intersection of Balls Covered by a Finite Union of Balls in Euclidean Spaces?”</span> <em>Journal of Optimization Theory and Applications</em> 187 (2): 431–47.
</div>
<div id="ref-Rybach" class="csl-entry" role="listitem">
Rybach, David, Christian Gollan, Ralf Schluter, and Hermann Ney. 2009. <span>“Audio Segmentation for Speech Recognition Using Segment Features.”</span> In <em>2009 IEEE International Conference on Acoustics, Speech and Signal Processing</em>, 4197–4200. <a href="https://doi.org/10.1109/ICASSP.2009.4960554">https://doi.org/10.1109/ICASSP.2009.4960554</a>.
</div>
<div id="ref-Staudacher2005ANM" class="csl-entry" role="listitem">
Staudacher, Martin, Stefan Telser, Anton Amann, Hartmann Hinterhuber, and Monika Ritsch-Marte. 2005. <span>“A New Method for Change-Point Detection Developed for on-Line Analysis of the Heart Beat Variability During Sleep.”</span> <em>Physica A-Statistical Mechanics and Its Applications</em> 349: 582–96.
</div>
<div id="ref-truong2020selective" class="csl-entry" role="listitem">
Truong, Charles, Laurent Oudre, and Nicolas Vayatis. 2020. <span>“Selective Review of Offline Change Point Detection Methods.”</span> <em>Signal Processing</em> 167: 107299.
</div>
<div id="ref-Verzelen2020" class="csl-entry" role="listitem">
Verzelen, Nicolas, Magalie Fromont, Matthieu Lerasle, and Patricia Reynaud-Bouret. 2020. <span>“Optimal Change-Point Detection and Localization.”</span> arXiv. <a href="https://doi.org/10.48550/ARXIV.2010.11470">https://doi.org/10.48550/ARXIV.2010.11470</a>.
</div>
<div id="ref-Yao" class="csl-entry" role="listitem">
Yao, Yi-Ching. 1984. <span>“Estimation of a Noisy Discrete-Time Step Function: Bayes and Empirical Bayes Approaches.”</span> <em>Ann. Statist.</em> 12 (4): 1434–47. <a href="https://doi.org/10.1214/aos/1176346802">https://doi.org/10.1214/aos/1176346802</a>.
</div>
<div id="ref-yao1988estimating" class="csl-entry" role="listitem">
———. 1988. <span>“Estimating the Number of Change-Points via Schwarz’criterion.”</span> <em>Statistics &amp; Probability Letters</em> 6 (3): 181–89.
</div>
<div id="ref-Zhang2007" class="csl-entry" role="listitem">
Zhang, Nancy, and David Siegmund. 2007. <span>“A Modified Bayes Information Criterion with Applications to the Analysis of Comparative Genomic Hybridization Data.”</span> <em>Biometrics</em> 63 (April): 22–32. <a href="https://doi.org/10.1111/j.1541-0420.2006.00662.x">https://doi.org/10.1111/j.1541-0420.2006.00662.x</a>.
</div>
</div>
</section>


<div id="quarto-appendix" class="default"><section id="session-information" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Session information</h2><div class="quarto-appendix-contents">

<div class="cell">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.2.2 (2022-10-31)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 22.04.2 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3
LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so

locale:
 [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       
 [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   
 [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          
[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   

attached base packages:
[1] stats     graphics  grDevices datasets  utils     methods   base     

loaded via a namespace (and not attached):
 [1] compiler_4.2.2  fastmap_1.1.0   cli_3.6.0       htmltools_0.5.4
 [5] tools_4.2.2     yaml_2.3.7      rmarkdown_2.20  knitr_1.42     
 [9] jsonlite_1.8.4  xfun_0.37       digest_0.6.31   rlang_1.0.6    
[13] renv_0.16.0     evaluate_0.20  </code></pre>
</div>
</div>
<!-- -->

</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></div></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{pishchagina2023,
  author = {Pishchagina, Liudmila and Rigaill, Guillem and Runge,
    Vincent},
  publisher = {Société Française de Statistique},
  title = {Geometric-Based {Pruning} {Rules} {For} {Change} {Point}
    {Detection} in {Multiple} {Independent} {Time} {Series}},
  journal = {Computo},
  date = {2023-05-22},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {We consider the problem of detecting multiple changes in
    multiple independent time series. It can be expressed as finding the
    segmentation that minimizes a given cost function. We focus on
    dynamic programming algorithms that solve this minimization problem
    exactly. When the number of changes is proportional to data length,
    an inequality-based pruning rule encoded in the PELT algorithm leads
    to a linear time complexity. Another type of pruning, called
    functional pruning, gives a close-to-linear time complexity whatever
    the number of changes, but only for a univariate cost function. We
    propose a few extensions of functional pruning for multiple
    independent time series based on the use of simple geometric shapes
    (balls and hyperrectangles). We focus on the Gaussian case, but some
    of our rules can be extended to the exponential family. In a
    simulation study, we compare the computational efficiency of
    different geometric-based pruning rules and show that for small
    dimensions (2, 3, 4) some of them ran significantly faster than
    inequality-based approaches in particular when the underlying number
    of changes is small compared to the data length.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-pishchagina2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Pishchagina, Liudmila, Guillem Rigaill, and Vincent Runge. 2023.
<span>“Geometric-Based Pruning Rules For Change Point Detection in
Multiple Independent Time Series.”</span> <em>Computo</em>, May. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, function() {
      let href = xref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note !== null) {
        if (id.startsWith('sec-')) {
          // Special case sections, only their first couple elements
          const container = document.createElement("div");
          if (note.children && note.children.length > 2) {
            for (let i = 0; i < 2; i++) {
              container.appendChild(note.children[i].cloneNode(true));
            }
            return container.innerHTML
          } else {
            return note.innerHTML;
          }
        } else {
          return note.innerHTML;
        }
      } else {
        return "";
      }
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb3" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Geometric-Based Pruning Rules For Change Point Detection in Multiple Independent Time Series"</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Liudmila Pishchagina</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    email: liudmila.pishchagina@univ-evry.fr</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://github.com/lpishchagina</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0000-0000-0000</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: UEVE</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">        department: LaMME</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">        url: http://www.math-evry.cnrs.fr/</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Guillem Rigaill</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://johndoe.someplace.themoon.org</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0000-0000-0000</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: INRAE, UEVE</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">        department: </span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">        url: </span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Vincent Runge</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://johndoe.someplace.themoon.org</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0000-0000-0000</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: UEVE</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co">        department: LaMME</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co">        url: http://www.math-evry.cnrs.fr/</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 2023-05-22</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co"> We consider the problem of detecting multiple changes in multiple independent time series. It can be expressed as finding the segmentation that minimizes a given cost function. We focus on dynamic programming algorithms that solve this minimization problem exactly. When the number of changes is proportional to data length, an inequality-based pruning rule encoded in the PELT algorithm leads to a linear time complexity. Another type of pruning, called functional pruning, gives a close-to-linear time complexity whatever the number of changes, but only for a univariate cost function. We propose a few extensions of functional pruning for multiple independent time series based on the use of simple geometric shapes (balls and hyperrectangles). We focus on the Gaussian case, but some of our rules can be extended to the exponential family. In a simulation study, we compare the computational efficiency of different geometric-based pruning rules and show that for small dimensions (2, 3, 4) some of them ran significantly faster than inequality-based approaches in particular when the underlying number of changes is small compared to the data length.</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [Multiple change point detection, dynamic programming, functional pruning, computational geometry]</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "template-computo-r"</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>A National Research Council report (@NRCreport2013) has identified change point detection as one of the "inferential giants" in massive data analysis. Detecting change points, either a posteriori or online, is important in areas as diverse as bioinformatics (@olshen2004circular, @Picard2005), econometrics (@bai2003computation, @Aue_monitoring), medicine (@Bosc2003, @Staudacher2005ANM, @Malladi2013OnlineBC), climate and oceanography (@Reeves2007, @DucrRobitaille2003, @Killick,  @Naoki2010), finance (@Andreou, @Fryzlewicz_2014), autonomous driving (@galceran2017multipolicy), entertainment (@Rybach, @Radke, @Davis2006), computer vision (@ranganathan2012pliss) or neuroscience (@jewell2020fast). The most common and prototypical change point detection problem is that of detecting changes in mean of a univariate Gaussian signal and a large number of approaches have been proposed to this problem (see among many others @Yao, @Lebarbier2005, @harchaoui2010multiple, @Frick2013, @fryzlewicz2020detecting and the reviews @truong2020selective, @aminikhanghahi2017survey).</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>*Penalized cost methods.* Some of these methods optimize a penalized cost function (see for example @Lebarbier2005, @Auger, @jackson2005algorithm, @Killick, @Rigaill2010, @Maidstone). These methods have good statistical guarantees (@Yao, @lavielle2000least, @Lebarbier2005) and have shown good performances in benchmark simulations (@fearnhead2018detecting) and on many applications ( @lai2005comparative, @liehrmann2021increased). From a computational perspective, these methods rely on dynamic programming algorithms that are at worst quadratic in the size of the data, $n$. However using inequality-based and functional pruning techniques (@Rigaill2010, @Killick, @Maidstone) the average run times are typically much smaller allowing to process very large profiles ($n&gt; 10^5$) in a matter of seconds or minutes. In detail, for one time series:</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>if the number of change points is proportional to $n$ both PELT (inequality-based pruning) and FPOP (functional pruning) (@Killick, @Maidstone) are on average linear.</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>if the number of change points is fixed, FPOP is quasi-linear (on simulations) while PELT is quadratic (@Maidstone).</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>*Multivariate extensions.* In this paper, we focus on the multivariate problem assuming the cost function or log-likelihood of a segment (denoted $\mathcal C$) can be decomposed as a sum over all $p$ dimensions. Informally that is</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>\mathcal C(segment) = \sum_{k=1}^{p} \mathcal C(segment, \hbox{ time series } k)\,.</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>In this context, the PELT algorithm can easily be extended for multiple time series. However, as for the univariate case, it will be algorithmically efficient only if the number of change points is large compared to $n$. In this paper, we study the extension of functional pruning techniques (and more specifically FPOP) to the multivariate case.</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>At each iteration, FPOP updates the set of parameter values for which a change position $\tau$ is optimal. As soon as this set is empty the change is pruned. For univariate time series, this set is a union of intervals in $\mathbb{R}$. For multi-parametric models, this set is equal to the intersection and difference of convex sets in $\mathbb{R}^p$ (@runge2020finite). It is typically non-convex, hard to update, and deciding whether it is empty or not is not straightforward.</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>In this work, we present a new algorithm, called Geometric Functional Pruning Optimal Partitioning (GeomFPOP). The idea of our method is to approximate the sets that are updated at each iteration of FPOP using simpler geometric shapes. Their simplicity of description and simple updating allow for a quick emptiness test.</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>The paper has the following structure. In @sec-changesMulti we introduce the penalized optimization problem for segmented multivariate time series. We then review the existing pruned dynamic programming methods for solving this problem. We define the geometric problem that occurs when using functional pruning. The new method, called GeomFPOP, is described in Section @sec-GeomFPOP and based on approximating intersection and exclusion set operators. In @sec-approximation we introduce two approximation types (sphere-like and rectangle-like) and define the approximation operators for each of them. We then compare in @sec-study the empirical efficiency of GeomFPOP with PELT on simulated data. </span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a><span class="fu"># Functional Pruning for Multiple Time Series{#sec-changesMulti}</span></span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model and Cost{#sec-model}</span></span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>We consider the problem of change point detection in multiple time series of length $n$ and dimension $p$. Our aim is to partition time into segments, such that in each segment the parameter associated to each time series is constant. For a time series $y$ we write $y = y_{1:n}=(y_1,\dots, y_n) \in(\mathbb{R}^p)^n$ with $y_i^k$ the $k$-th component of the $p$-dimensional point $y_i\in\mathbb{R}^p$ in position $i$ in vector $y_{1:n}$. We also use the notation $y _{i:j} = (y_i,\dots, y_j)$ to denote points from index $i$ to $j$. If we assume that there are $M$ change points in a time series, this corresponds to time series splits into $M+1$ distinct segments. Each segment $m \in \{1,\dots, M+1\}$ is generated by independent random variables from a multivariate distribution with  the segment-specific parameter $\theta_m = (\theta_m^1,\dots, \theta_m^p)  \in \mathbb{R}^p$. A segmentation with $M$ change points is defined by the vector of integers $\tau =(\tau_0 = 0, \tau_1,\dots,\tau_M,\tau_{M+1}=n)$. Segments are given by the sets of indices $\{\tau_i+1,\dots, \tau_{i+1}<span class="sc">\}</span>$ with $i$ in $<span class="sc">\{</span>0,1,\ldots,M<span class="sc">\}</span>$. </span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>We define the set $S_t$ of all possible change point locations related to the segmentation of data points between positions $1$ to $t$ as</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>S_t = <span class="sc">\{</span>\tau = (\tau_0,\tau_1,\dots,\tau_M, \tau_{M+1}) \in \mathbb{N}^{M+2} | 0=\tau_{0} &lt;\tau_1 &lt; \dots &lt; \tau_M &lt; \tau_{M+1}=t<span class="sc">\}</span>\,.</span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>Usually the number of changes $M$ is unknown, and has to be estimated. Many approaches to detecting change points define a cost function for segmentation using the opposite log-likelihood (times two). Here the opposite log-likelihood (times two) linked to data point $y_j$ is given by function $\theta \mapsto \Omega(\theta,y_j)$, where $\theta = (\theta^1,\dots, \theta^p) \in \mathbb R^p$. Over a segment from $i$ to $t$, the parameter remains the same and the segment cost $\mathcal C$ is given by</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>        \begin{gathered}</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>            \mathcal C(y_{i:t}) = \min_{\theta \in \mathbb{R}^p} \sum_{j=i}^{t}\Omega(\theta, y_j) = \min_{\theta \in \mathbb{R}^p} \sum_{j=i}^{t} \left(\sum_{k=1}^{p} \omega(\theta^k, y_j^k)\right)\,,</span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>        \end{gathered}</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>$${#eq-Cy_it}   </span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>with $\omega$ the atomic likelihood function associated with $\Omega$ for each univariate time series. This decomposition is made possible by the independence hypothesis between dimensions. Notice that function $\omega$ could have been dimension-dependent with a mixture of different distributions (Gauss, Poisson, negative binomial, etc.). In our study, we consider the same data model for all dimensions.</span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>We consider a penalized version of the cost by a penalty $\beta &gt; 0$, because without a penalty we would end up with $n$ segments. Summing over all segments we end up with a penalty that is linear in the number of segments. Such choice is common in the literature (@yao1988estimating, @Killick) although some other penalties have been proposed (@Zhang2007, @Lebarbier2005, @Verzelen2020). The optimal penalized cost associated with our segmentation problem is then defined by</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>    Q_n = \min_{\tau \in S_n} \sum_{i=0}^{M} <span class="sc">\{</span>\mathcal C(y_{(\tau_{i}+1):\tau_{i+1}})+\beta<span class="sc">\}</span>\,.</span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>$${#eq-Q_n}</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>The optimal segmentation $\tau$ is obtained by the argminimum in @eq-Q_n.</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a><span class="fu">## Functional Pruning Dynamic Programming Algorithm {#sec-UpdateRule}</span></span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>The idea of the Optimal Partitioning (OP) method (@jackson2005algorithm) is to search for the last change point defining the last segment in data $y_{1:t}$ at each iteration (with $Q_0 = 0$), which leads to the recursion: </span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>Q_{t} = \min_{i\in<span class="sc">\{</span>0,\dots,t-1<span class="sc">\}</span>}\Big(Q_i + \mathcal C(y_{({i+1}:t})+ \beta \Big)\,.</span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>$${#eq-OP}</span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>*Functional description.* In the FPOP method we introduce a last segment parameter $\theta = (\theta^1,\dots, \theta^p) \in \mathbb R^p$ and define a functional cost $\theta \mapsto Q_t(\theta)$ depending on $\theta$, that takes the following form:</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>Q_t(\theta) = \min_{\tau \in S_t} \Big( \sum_{i=0}^{M-1} <span class="sc">\{</span>\mathcal C(y_{(\tau_{i}+1):\tau_{i+1}})+\beta<span class="sc">\}</span> + \sum_{j=\tau_{M}+1}^{t}\Omega(\theta, y_j) + \beta \Big)\,.</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>As explained in @Maidstone, we can compute the function $Q_{t+1}(\cdot)$ based only on the knowledge of $Q_{t}(\cdot)$ as for each integer $t$ from $0$ to $n-1$. We have:</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>        Q_{t+1}(\theta) = \min <span class="sc">\{</span>Q_t(\theta),m_t +\beta <span class="sc">\}</span> + \Omega(\theta, y_{t+1})\,, </span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>$${#eq-Q_tpl1}</span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>for all $\theta \in \mathbb{R}^p$, with $m_t = \min_\theta Q_t(\theta)$ and the initialization $Q_0(\theta) = 0$, so that $Q_1(\theta) = \Omega(\theta,y_1)$.</span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>By looking closely at this relation, we see that each function $Q_t$ is a piece-wise continuous function consisting of at most $t$ different functions  on $\mathbb R^p$, denoted  $q^i_t$:</span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>    \begin{gathered}</span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>        Q_t(\theta) = \min_{i \in <span class="sc">\{</span>1,\dots,t <span class="sc">\}</span>} \left<span class="sc">\{</span>q_t^i(\theta)\right<span class="sc">\}</span>\,,   </span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>    \end{gathered}</span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>$${#eq-Qq_it}</span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>where the $q_t^i$ functions are given by explicit formulas: </span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>    \begin{gathered}</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>        q_t^i(\theta) = m_{i-1} + \beta + \sum_{j = i}^{t} \Omega(\theta,y_j)\,,\quad\theta \in \mathbb R^p\,,\quad i = 1,\dots,t.  </span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>    \end{gathered}</span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>$${#eq-q_it}</span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>and</span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>    m_{i-1} =  \min_{\theta \in \mathbb R^p}Q_{i-1}(\theta) = \min_{j \in <span class="sc">\{</span> 1,\dots,i-1<span class="sc">\}</span>}\left<span class="sc">\{</span> \min_{\theta \in \mathbb R^p}q_{i-1}^j(\theta) \right<span class="sc">\}</span>.</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>$${#eq-m_im1}</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>It is important to notice that each $q_t^i$ function is associated with the last change point $i-1$ and the last segment is given by indices from $i$ to $t$. Consequently, the last change point at step $t$ in $y_{1:t}$ is denoted as $\hat\tau_t$ $( \hat \tau_t \le t-1)$ and is given by</span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>        \begin{gathered}</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>            \hat\tau_t = Arg\,min_{i \in <span class="sc">\{</span>1,\dots,t<span class="sc">\}</span>} \left<span class="sc">\{</span> \min_{\theta \in \mathbb{R}^p} q_t^i(\theta)\right<span class="sc">\}</span>-1.</span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>        \end{gathered}</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>$${#eq-tau_t}</span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>*Backtracking.* Knowing the values of $\hat{\tau}_t$ for all $t=1, \dots, n$, we can always restore the optimal segmentation at time $n$ for $y_{1:n}$. This procedure is called backtracking. The vector $cp(n)$ of ordered change points in the optimal segmentation of $y_{1:n}$ is determined recursively by the relation $cp(n) = (cp(\hat \tau_n), \hat \tau_n)$ with stopping rule $cp(0)=\emptyset$.    </span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>*Parameter space description.* Applying functional pruning requires a precise analysis of the recursion {eq-Q_tpl1} that depends on the property of the cost function~$\Omega$. In what follows we consider three choices based on a Gaussian, Poisson, and negative binomial distribution assumption on the data. The exact formulas of these cost functions are given in @sec-logLikeExamples.</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>We denote the set of parameter values for which the function $q^i_t(\cdot)$ is optimal as:</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>        \begin{gathered}</span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>          Z_t^i = \left<span class="sc">\{</span> \theta \in \mathbb R^p|Q_t(\theta) = q_{t}^i(\theta) \right<span class="sc">\}</span>, \quad i = 1,\dots,t.</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>        \end{gathered}</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>$${#eq-defZ}</span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>The key idea behind functional pruning is that the $Z_t^i$ are nested ($Z_{t+1}^i \subset Z_t^i$) thus as soon as we can prove the emptiness of one set $Z_t^i$, we delete its associated $q_t^i$ function and do not have to consider its minimum anymore at any further iteration (proof in next @sec-geometry). In dimension $p = 1$ this is reasonably easy. In this case, the sets $Z^i_t$ ($i=1,\dots, t$) are unions of intervals and an efficient functional pruning rule is possible by updating a list of these intervals for $Q_{t}$. This approach is implemented in FPOP (@Maidstone).</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>In dimension $p \ge 2$ it is not so easy anymore to keep track of the emptiness of the sets $Z^i_t$. We illustrate the dynamics of the $Z^i_t$ sets in @fig-Figure1 in the bi-variate Gaussian case. Each color is associated with a set $Z_t^i$ (corresponding to a possible change at $i-1$) for $t$ equal $1$ to $5$. This plot shows that sets $Z_t^i$ can be non-convex.</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>::: {#fig-Figure1}  </span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a><span class="al">![](images/Figure 1 Z sets over time set_seed_617.png)</span></span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>The sets $Z^i_t$ over time for the bi-variate independent Gaussian model on time series without change $y= \left <span class="sc">\{\{</span>0,29; 1,86; 0,9; -1,26; 1,22<span class="sc">\}</span>,<span class="sc">\{</span> 1,93;  -0,02;  -2,51; 0,91;  1,11<span class="sc">\}</span>\right<span class="sc">\}</span>$. </span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>From left to right we represent at time $t=1, 2, 3, 4,$ and $5$ the parameter space $(\theta^1, \theta^2).$ Each $Z^i_t$ is represented by a color. The change $1$ associated with  quadratics $2$ is pruned at $t = 3$. Notice that each time sequence of $Z^i_t$ with $i$ fixed is a nested sequence of sets.</span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a><span class="fu">## Geometric Formulation of Functional Pruning{#sec-geometry}</span></span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>To build an efficient pruning strategy for dimension $p\ge2$ we need to test the emptiness of the sets $Z^i_t$ at each iteration. Note that to get $Z_t^i$ we need to compare the functional cost $q^i_t$ with any other functional cost $q^j_{t}$, $j=1,\dots, t,\, j\neq i$. This leads to the definition of the following sets.</span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a>::: {#def-defS}</span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a><span class="fu">## S-type set</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>We define $S$-type set $S^i_j$ using the function $\Omega$ as </span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>S_j^i = \left<span class="sc">\{</span> \theta \in \mathbb{R}^p \,|\, \sum_{u=i+1}^j \Omega(\theta, y_u) \le m_{j}-m_{i}\right<span class="sc">\}</span>\,,\hbox{ when } i &lt; j</span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>and $S_i^i = \mathbb R^p$. We denote the set of all possible S-type sets as $\mathbf{S}$.</span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>To ease some of our calculations, we now introduce some additional notations. For $\theta = (\theta^1,\dots,\theta^p) \in \mathbb{R}^p$, $1 \le i &lt; j \le n$ we define $p$ univariate functions $\theta^k \mapsto s^k_{ij}(\theta^k)$ associated to the $k$-th time series as</span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>       &amp;s^k_{ij}(\theta^k) &amp; =&amp;\sum_{u = i+1}^{j} \omega(\theta^k,y_u^k), \quad  k = 1,\dots,p\,.</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>    \end{aligned}</span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>$${#eq-setS}</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>We introduce a constant $\Delta_{ij}$ and a function $\theta \mapsto s_{ij}(\theta)$:</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>    \left<span class="sc">\{</span></span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>       \Delta_{ij} &amp; =  \,m_j - m_{i}\,,<span class="sc">\\</span></span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>       s_{ij}(\theta) &amp; =  \sum_{k=1}^p s^k_{ij}(\theta^k)- \Delta_{ij}\,,</span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>    \end{aligned}</span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>    \right.</span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>$${#eq-setSfunc}</span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>where $m_{i}$ and $m_j$ are defined as in @eq-m_im1. The sets $S_j^i$ for $i &lt; j$ are also described by relation </span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>    \begin{gathered}</span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>        S_j^i = s_{ij}^{-1} (-\infty,0]\,.</span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>    \end{gathered}</span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>$${#eq-setS}</span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>In @fig-Figure2 we present the level curves for three different parametric models given by $s_{ij}^{-1} (<span class="sc">\{</span>w<span class="sc">\}</span>)$ with $w$ a real number. Each of these curves encloses an S-type set.</span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>::: {#fig-Figure2}  </span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a><span class="al">![](images/Figure 2 Contoure of S-type sets and cost .png)</span></span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>Three examples of the level curves of a function $s_{ij}$ for bi-variate time series $<span class="sc">\{</span>x,y<span class="sc">\}</span>$. We use the following simulations for univariate time series : (a) $x\sim \mathcal{N}(0,1)$, $y\sim \mathcal{N}(0,1)$, (b) $x \sim \mathcal{P}(1)$, $y \sim \mathcal{P}(3)$, (c) $x\sim \mathcal{NB}(0.5,1)$, $y\sim \mathcal{NB}(0.8, 1)$.</span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>At time $t = 1,\dots, n$ we define the following sets</span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a> associated to the last change point index $i-1$:</span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a>$\mathtt{past}\,\mathtt{set} \,\mathcal{P}^i$</span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a>        \begin{gathered}</span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a>            \mathcal{P}^i =<span class="sc">\{</span>S_{i}^u,\, u = 1,\dots,i-1<span class="sc">\}</span>\,.</span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>        \end{gathered}</span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>$${#eq-setE}</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>$\mathtt{future}\, \mathtt{set} \,\mathcal{F}^i(t)$ </span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a>        \begin{gathered}</span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>            \mathcal{F}^i(t) =<span class="sc">\{</span>S_{v}^i, \, v = i,\dots,t<span class="sc">\}</span>\,.</span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>        \end{gathered}</span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a>$${#eq-setI}</span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>We denote the cardinal of a set $\mathcal{A}$ as $|\mathcal{A}|$. Using these two sets of sets, the $Z^i_t$ have the following description.</span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a>:::{#prp-proposition_sets}</span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a>At iteration $t$, the functional cost  $Q_t(\cdot)$ defines the subsets  $Z_t^i$ ($i=1,\dots, t$), each of them being the intersection of  the sets in $\mathcal{F}^i(t)$ minus the union of the sets in $\mathcal{P}^i$. </span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>    \begin{gathered}</span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>        Z_t^i = (\cap_{S\in \mathcal{F}^i(t)}S) \setminus (\cup_{S\in \mathcal{P}^i}S)\,,\quad i = 1,\dots,t.</span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a>    \end{gathered}</span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a>$${#eq-setsZ}</span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a>Based on the definition of the set $Z_t^i$, the proof is straightforward. Parameter value $\theta$ is in  $Z_t^i$ if and only if $q_t^i(\theta) \le q_t^u(\theta)$ for all $u \ne i$; these inequalities define the past set (when $u &lt; i$) and the future set (when $u&gt;i$). Notice that, in case $i = t$, $\cap_{S\in \mathcal{F}^i(t)}S = \mathbb R^p$. </span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a>:::{#cor-col1}</span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a>The sequence $\zeta^i = (Z_t^i)_{t\ge i}$ is a nested sequence of sets.</span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a>Indeed, $Z_{t+1}^i$ is equal to $Z_t^i$ with an additional intersection in the future set. Based on @cor-col1, as soon as we prove that the set $Z_t^i$, is empty, we delete its associated $q_t^i$ function and, consequently, we can prune the change point $i-1$. In this context, functional and inequality-based pruning have a simple geometric interpretation.</span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a>*Functional pruning geometry.* The position $i-1$ is pruned at step $t+1$, in $Q_{t+1}(\cdot),$ if the intersection set of $\cap_{S\in \mathcal{F}^i(t)}S$ is covered by the union set $\cup_{S\in \mathcal{P}^i}S$.</span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a>*Inequality-based pruning geometry.* The inequality-based pruning of PELT is equivalent to the geometric rule: position $i-1$ is pruned at step $t+1$ if the set $S_t^i$ is empty. In that case, the intersection  set $\cap_{S\in \mathcal{F}^i(t)}S$ is empty, and therefore $Z_t^i$ is also empty using @eq-setsZ. This shows that if a change is pruned using inequality-based pruning it is also pruned using functional pruning. For the dimension $p =1$ this claim was theoretically proved in @Maidstone.</span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a>The construction of set $Z^i_t$ using @prp-proposition_sets is illustrated in @fig-Figure3 for a bi-variate independent Gaussian case: we have the intersection of three S-type sets and the subtraction of three S-type sets.</span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a>:::{#fig-Figure3}  </span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a><span class="al">![](images/Figure 3 Bilding Z with 3 past and 3 future disks set_seed_21.pdf)</span></span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a>Examples of building a set $Z^i_t$ with $\lvert\mathcal{P}^i\rvert = \lvert\mathcal{F}^i(t)\rvert = 3$ for the Gaussian case in 2-D ($\mu = 0,\sigma=1$). The green disks are S-type sets of the past set $\mathcal{P}^i$. The blue disks are  S-type sets of the future set $\mathcal{F}^i(t)$.</span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a><span class="fu"># Geometric Functional Pruning Optimal Partitioning {#sec-GeomFPOP}</span></span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a><span class="fu">## General Principle of GeomFPOP{#sec-principle}</span></span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a>Rather than considering an exact representation of the $Z^i_t$, our idea is to consider a hopefully slightly larger set that is easier to update. To be specific for each $Z^i_t$ we introduce $\tilde{Z}^i_t$, called *testing set*, such that $Z^i_t\subset \tilde{Z}^i_t$. If at time $t$ $\tilde{Z}^i_t$ is empty thus is $Z^i_t$ and thus change $i-1$ can be pruned. From proposition \eqref{proposition_sets} we have that starting from $Z = \mathbb{R}^p$ the set $Z^i_t$ is obtained by successively applying two types of operations: intersection with an S-type set  $S$ $(Z\cap S)$ or subtraction of an S-type set $S$ $(Z\setminus S)$. Similarly, starting from $\tilde{Z} = \mathbb{R}^p$ we obtain $\tilde{Z}^i_t$ by successively applying approximation of these intersection and subtraction operations. Intuitively, the complexity of the resulting algorithm is a combination of the efficiency of the pruning and the easiness of updating the testing set. </span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a>*A Generic Formulation of GeomFPOP.* In what follows we will generically describe GeomFPOP, that is without specifying the precise structure of the testing set $\tilde{Z}^i_t$. We call $\mathbf{\tilde{Z}}$ the set of all possible $\tilde{Z}^i_t$ and assume the existence of two operators $\cap_{\tilde{Z}}$ and $\setminus_{\tilde{Z}}$. We have the following assumptions for these operators.</span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a>:::{#def-assumption1}</span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a>The two operators $\cap_{\tilde{Z}}$ and $\setminus_{\tilde{Z}}$ are such that:</span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a><span class="ss">  1. </span>the left input is a $\tilde{Z}$-type set (that is an element of $\tilde{\mathbf{Z}}$);</span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a><span class="ss">  2. </span>the right input is a $S$-type set;</span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a><span class="ss">  3. </span>the output is a $\tilde{Z}$-type set;</span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a><span class="ss">  4. </span>$\tilde{Z} \cap S \subset \tilde{Z} \cap_{\tilde{Z}} S$ and $\tilde{Z} \setminus S \subset \tilde{Z} \setminus_{\tilde{Z}} S$.</span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a>We give a proper description of two types of testing sets and their approximation operators in @sec-approximation.</span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a>At each iteration $t$ GeomFPOP will construct $\tilde{Z}^i_{t+1}$ from $\tilde{Z}^i_{t}$, $\mathcal{P}^i$ and, $\mathcal{F}^i(t)$ iteratively using the two operators $\cap_{\tilde{Z}}$ and $\setminus_{\tilde{Z}}$. To be specific, we define $S_j^F$ the j-th element of $\mathcal{F}^i(t)$ and $S_P^j$ the j-th element of $\mathcal{P}^i$, we use the following iteration:</span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a>    \left<span class="sc">\{</span></span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a>      \begin{aligned}</span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a>       A_{0} =\tilde{Z}^i_{t} \,, &amp; \quad A_j = A_{j-1}\,\cap_{\tilde{Z}}\, S_j^F\,, &amp; j = 1,\dots , |\mathcal{F}^i(t)|\,,<span class="sc">\\</span></span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a>        B_{0} =A_{|\mathcal{F}^i(t)|}\,, &amp; \quad B_j = B_{j-1}\,\setminus_{\tilde{Z}} \, S_P^j\,, &amp; j = 1,\dots , |\mathcal{P}^i| \,,<span class="sc">\\</span></span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a>    \end{aligned}  </span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a>    \right.</span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a>and define $\tilde{Z}^i_{t+1} = B_{|\mathcal{P}^i|}.$</span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a>Using the fourth property of @def-assumption1 and @prp-proposition_sets, we get that at any time of the algorithm $\tilde{Z}^i_t$ contains ${Z}^i_t.$</span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a>The pseudo-code of this procedure is described in @fig-alg1. The $\mathtt{select}(\mathcal{A})$ step in @fig-alg1, where $\mathcal{A} \subset  \mathbf S$, returns a subset of $\mathcal{A}$ in  $\mathbf S$. By default, $\mathtt{select}(\mathcal{A}) := \mathcal{A}$.</span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a>::: {#fig-alg1}</span>
<span id="cb3-276"><a href="#cb3-276" aria-hidden="true" tabindex="-1"></a><span class="al">![](images/alg1.png)</span></span>
<span id="cb3-277"><a href="#cb3-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-278"><a href="#cb3-278" aria-hidden="true" tabindex="-1"></a>Geometric update rule of $\tilde{Z}^i_t$</span>
<span id="cb3-279"><a href="#cb3-279" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-280"><a href="#cb3-280" aria-hidden="true" tabindex="-1"></a>We denote the set of change points candidates at time $t$ as $\tau_t$. Note that for any $(i-1)\in \tau_t$  the sum of $|\mathcal P^i|$ and $|\mathcal F^i(t)|$ is $|\tau_t|$. </span>
<span id="cb3-281"><a href="#cb3-281" aria-hidden="true" tabindex="-1"></a>With the default $\mathtt{select}()$ procedure we do $\mathcal{O}(p|\tau_t|)$ operations in @fig-alg1. By limiting the number of elements returned by $\mathtt{select}()$ we can reduce the complexity.</span>
<span id="cb3-282"><a href="#cb3-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-283"><a href="#cb3-283" aria-hidden="true" tabindex="-1"></a>:::{.remark}</span>
<span id="cb3-284"><a href="#cb3-284" aria-hidden="true" tabindex="-1"></a>For example, if the operator $\mathcal{A} \mapsto \mathtt{select}(\mathcal{A})$, regardless of $|\mathcal A|$, always returns a subset of constant size, then the overall complexity of GeomFPOP is at worst equal to that of PELT with $\sum_{t=1}^{n}\mathcal{O}(p|\tau_t|)$ time complexity.</span>
<span id="cb3-285"><a href="#cb3-285" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-286"><a href="#cb3-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-287"><a href="#cb3-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-288"><a href="#cb3-288" aria-hidden="true" tabindex="-1"></a>Using this $\mathtt{updateZone}()$ procedure we can now informally describe the GeomFPOP algorithm. At each iteration the algorithm will</span>
<span id="cb3-289"><a href="#cb3-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-290"><a href="#cb3-290" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>find the minimum value for $Q_t$, $m_t$; and the best position for last change point $\hat \tau_t$ (note that this step is standard: as in the PELT algorithm we need to minimize the cost of the last segment defined in @eq-Cy_it);</span>
<span id="cb3-291"><a href="#cb3-291" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>compute all sets $\tilde{Z}_{t}^{i}$ using $\tilde{Z}_{t+1}^{i}$, $\mathcal{P}^i$, and $\mathcal{F}^i(t)$ with the $\mathtt{updateZone}()$ procedure;</span>
<span id="cb3-292"><a href="#cb3-292" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>remove changes such that $\tilde{Z}_{t+1}^{i}$ is empty.</span>
<span id="cb3-293"><a href="#cb3-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-294"><a href="#cb3-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-295"><a href="#cb3-295" aria-hidden="true" tabindex="-1"></a>To simplify the pseudo-code of GeomFPOP, we also define the following operators:</span>
<span id="cb3-296"><a href="#cb3-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-297"><a href="#cb3-297" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>$\mathtt{bestCost<span class="sc">\&amp;</span>Tau}(t)$ operator returns two values: the minimum value of $Q_t$, $m_t$, and the best position for last change point $\hat \tau_t$ at time $t$ (see {sec-UpdateRule); </span>
<span id="cb3-298"><a href="#cb3-298" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>$\mathtt{getPastFutureSets}(i,t)$ operator returns a pair of sets ($\mathcal{F}^i(t)$, $\mathcal{P}^i$) for change point candidate $i-1$ at time $t$;</span>
<span id="cb3-299"><a href="#cb3-299" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>$\mathtt{backtracking}(\hat\tau, n)$ operator returns the optimal segmentation for $y_{1:n}$. </span>
<span id="cb3-300"><a href="#cb3-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-301"><a href="#cb3-301" aria-hidden="true" tabindex="-1"></a>The pseudo-code of GeomFPOP is presented in @fig-alg2.</span>
<span id="cb3-302"><a href="#cb3-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-303"><a href="#cb3-303" aria-hidden="true" tabindex="-1"></a>::: {#fig-alg2}</span>
<span id="cb3-304"><a href="#cb3-304" aria-hidden="true" tabindex="-1"></a><span class="al">![](images/alg2.png)</span></span>
<span id="cb3-305"><a href="#cb3-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-306"><a href="#cb3-306" aria-hidden="true" tabindex="-1"></a>GeomFPOP algorithm</span>
<span id="cb3-307"><a href="#cb3-307" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-308"><a href="#cb3-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-309"><a href="#cb3-309" aria-hidden="true" tabindex="-1"></a><span class="fu"># Approximation Operators $\cap_{\tilde{Z}}$ and $\setminus_{\tilde{Z}}$ {#sec-approximation}</span></span>
<span id="cb3-310"><a href="#cb3-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-311"><a href="#cb3-311" aria-hidden="true" tabindex="-1"></a>The choice of the geometric structure and the way it is constructed directly affects the computational cost of the algorithm. We consider two types of testing set $\tilde{Z} \in \mathbf{\tilde{Z}}$, a S-type set $\tilde{S}\in \mathbf{S}$ (see @def-defS) and a hyperrectangle $\tilde{R}\in  \mathbf{R}$ defined below.</span>
<span id="cb3-312"><a href="#cb3-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-313"><a href="#cb3-313" aria-hidden="true" tabindex="-1"></a>:::{#def-Hyperrectangle}</span>
<span id="cb3-314"><a href="#cb3-314" aria-hidden="true" tabindex="-1"></a><span class="fu">## Hyperrectangle</span></span>
<span id="cb3-315"><a href="#cb3-315" aria-hidden="true" tabindex="-1"></a>Given two vectors in $\mathbb{R}^p$, $\tilde{l}$ and $\tilde{r}$ we define the set $\tilde{R}$, called *hyperrectangle*, as:</span>
<span id="cb3-316"><a href="#cb3-316" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-317"><a href="#cb3-317" aria-hidden="true" tabindex="-1"></a>            \tilde{R} = <span class="co">[</span><span class="ot">\tilde{l}_1,\tilde{r}_1</span><span class="co">]</span>\times \dots \times<span class="co">[</span><span class="ot">\tilde{l}_p,\tilde{r}_p</span><span class="co">]</span>\,. <span class="sc">\\</span></span>
<span id="cb3-318"><a href="#cb3-318" aria-hidden="true" tabindex="-1"></a>$$ {#eq-setR}</span>
<span id="cb3-319"><a href="#cb3-319" aria-hidden="true" tabindex="-1"></a>We denote the set of all possible sets $\tilde{R}$ as $\mathbf{R}$.</span>
<span id="cb3-320"><a href="#cb3-320" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-321"><a href="#cb3-321" aria-hidden="true" tabindex="-1"></a>To update the testing sets we need to give the strict definition of the operators $\cap_{\tilde{Z}}$ and $\setminus_{\tilde{Z}}$ for each type of testing set. To facilitate the following discussion, we rename them. For the first type of geometric structure, we rename the testing set $\tilde{Z}$ as $\tilde{S}$, the operators $\cap_{\tilde{Z}}$ and $\setminus_{\tilde{Z}}$ as $\cap_{S}$ and $\setminus_{S}$ and $\tilde{Z}$-type approximation as S-type approximation. And, likewise, we rename the testing set $\tilde{Z}$ as $\tilde{R}$, the operators $\cap_{\tilde{Z}}$ and $\setminus_{\tilde{Z}}$ as $\cap_{R}$ and $\setminus_{R}$ and $\tilde{Z}$-type approximation as R-type approximation for the second type of geometric structure.</span>
<span id="cb3-322"><a href="#cb3-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-323"><a href="#cb3-323" aria-hidden="true" tabindex="-1"></a><span class="fu">## S-type Approximation</span></span>
<span id="cb3-324"><a href="#cb3-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-325"><a href="#cb3-325" aria-hidden="true" tabindex="-1"></a>With this approach, our goal is to keep track of the fact that at time $t = 1,\dots, n$ there is a pair of changes $(u_1,u_2)$, with $u_1 &lt; i &lt; u_2\le t$</span>
<span id="cb3-326"><a href="#cb3-326" aria-hidden="true" tabindex="-1"></a>such that $S^i_{u_2}\subset S^{u_1}_{i}$ or there is a pair of changes $(v_1,v_2)$, with $i  &lt; v_1 &lt; v_2\le t$  such that $S^i_{v_1}\cap S^i_{v_2}$ is empty. If at time $t$ at least one of these conditions is met, we can guarantee that the set $\tilde{S}$ is empty, otherwise, we propose to keep as the result of approximation the last future S-type set $S^i_t$, because it always includes the set $Z^i_t$. This allows us to quickly check and prove (if $\tilde{S} =\emptyset$) the emptiness of set $Z^i_t$.</span>
<span id="cb3-327"><a href="#cb3-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-328"><a href="#cb3-328" aria-hidden="true" tabindex="-1"></a>We consider two generic S-type sets, $S$ and $\tilde{S}$  from $\mathbf{S}$, described as in @eq-setS by the functions $s$ and  $\tilde{s}$:</span>
<span id="cb3-329"><a href="#cb3-329" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-330"><a href="#cb3-330" aria-hidden="true" tabindex="-1"></a>         s(\theta) = \sum_{k=1}^p s^k(\theta^k)- \Delta\,,\quad\quad</span>
<span id="cb3-331"><a href="#cb3-331" aria-hidden="true" tabindex="-1"></a>        \tilde{s}(\theta) = \sum_{k=1}^p {\tilde{s}}^{k}(\theta^k)- \tilde{\Delta}\,. </span>
<span id="cb3-332"><a href="#cb3-332" aria-hidden="true" tabindex="-1"></a>$$ {#eq-setSStilde}</span>
<span id="cb3-333"><a href="#cb3-333" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-334"><a href="#cb3-334" aria-hidden="true" tabindex="-1"></a>:::{#def-def_oper_S}</span>
<span id="cb3-335"><a href="#cb3-335" aria-hidden="true" tabindex="-1"></a>For all  $S$ and $\tilde{S}$ in $\mathbf{S}$ </span>
<span id="cb3-336"><a href="#cb3-336" aria-hidden="true" tabindex="-1"></a>we define the operators $\cap_{S}$ and $\setminus_{S}$ as:</span>
<span id="cb3-337"><a href="#cb3-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-338"><a href="#cb3-338" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-339"><a href="#cb3-339" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb3-340"><a href="#cb3-340" aria-hidden="true" tabindex="-1"></a>        &amp;\tilde{S}\, \cap_{S}\, S&amp; = \left<span class="sc">\{</span></span>
<span id="cb3-341"><a href="#cb3-341" aria-hidden="true" tabindex="-1"></a>        \begin{aligned}</span>
<span id="cb3-342"><a href="#cb3-342" aria-hidden="true" tabindex="-1"></a>            &amp; \emptyset \,,  &amp; \hbox{ if }  \tilde{S}\cap S = \emptyset \,,<span class="sc">\\</span></span>
<span id="cb3-343"><a href="#cb3-343" aria-hidden="true" tabindex="-1"></a>            &amp; \tilde{S}\,, &amp; \hbox{otherwise}\,.<span class="sc">\\</span></span>
<span id="cb3-344"><a href="#cb3-344" aria-hidden="true" tabindex="-1"></a>        \end{aligned} </span>
<span id="cb3-345"><a href="#cb3-345" aria-hidden="true" tabindex="-1"></a>        \right.<span class="sc">\\</span></span>
<span id="cb3-346"><a href="#cb3-346" aria-hidden="true" tabindex="-1"></a>         &amp;\tilde{S} \,\setminus_{S}\, S   &amp; = \left<span class="sc">\{</span></span>
<span id="cb3-347"><a href="#cb3-347" aria-hidden="true" tabindex="-1"></a>        \begin{aligned}</span>
<span id="cb3-348"><a href="#cb3-348" aria-hidden="true" tabindex="-1"></a>        &amp; \emptyset \,,  &amp; \hbox{ if }  \tilde{S} \subset S\,,<span class="sc">\\</span></span>
<span id="cb3-349"><a href="#cb3-349" aria-hidden="true" tabindex="-1"></a>        &amp; \tilde{S}\,, &amp; \hbox{otherwise}\,.<span class="sc">\\</span></span>
<span id="cb3-350"><a href="#cb3-350" aria-hidden="true" tabindex="-1"></a>        \end{aligned} </span>
<span id="cb3-351"><a href="#cb3-351" aria-hidden="true" tabindex="-1"></a>        \right.</span>
<span id="cb3-352"><a href="#cb3-352" aria-hidden="true" tabindex="-1"></a>    \end{aligned}</span>
<span id="cb3-353"><a href="#cb3-353" aria-hidden="true" tabindex="-1"></a>$$ {#eq-Zempty}</span>
<span id="cb3-354"><a href="#cb3-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-355"><a href="#cb3-355" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-356"><a href="#cb3-356" aria-hidden="true" tabindex="-1"></a>As a consequence, we only need an easy way to detect any of these two geometric configurations: $\tilde{S}\cap S$ and $\tilde{S} \subset S$.</span>
<span id="cb3-357"><a href="#cb3-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-358"><a href="#cb3-358" aria-hidden="true" tabindex="-1"></a>In the Gaussian case, the S-type sets are $p$-balls and an easy solution exists based on comparing radii (see @sec-InterandExclBalls for details). In the case of other models (as Poisson or negative binomial), intersection and inclusion tests are performed through an iterative algorithm solving convex problems (see @append:IntersectionSsets). This iterative approach is not constant in time, which is why we also considered another type of testing set.</span>
<span id="cb3-359"><a href="#cb3-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-360"><a href="#cb3-360" aria-hidden="true" tabindex="-1"></a><span class="fu">## R-type Approximation</span></span>
<span id="cb3-361"><a href="#cb3-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-362"><a href="#cb3-362" aria-hidden="true" tabindex="-1"></a>Here, we approximate the sets $Z^i_t$ by hyperrectangles $\tilde{R}^i_t \in \mathbf{R}$. A key insight of this approximation is that given a hyperrectangle $R$ and an S-type set $S$ we can efficiently (in $\mathcal{O}(p)$ using @prp-prop_solution_rect) recover the best hyperrectangle approximation of $R \cup S$ and $R \setminus S.$ Formally we define these operators as follows.</span>
<span id="cb3-363"><a href="#cb3-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-364"><a href="#cb3-364" aria-hidden="true" tabindex="-1"></a>:::{#def-operR}</span>
<span id="cb3-365"><a href="#cb3-365" aria-hidden="true" tabindex="-1"></a><span class="fu">## Hyperrectangles Operators $\cap_{R}$, $\setminus_{R}$ ) </span></span>
<span id="cb3-366"><a href="#cb3-366" aria-hidden="true" tabindex="-1"></a>For all  $R, \tilde{R} \in \mathbf{R}$ and $S\in \mathbf{S}$  we define the operators $\cap_{R}$ and $\setminus_{R}$ as:</span>
<span id="cb3-367"><a href="#cb3-367" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-368"><a href="#cb3-368" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb3-369"><a href="#cb3-369" aria-hidden="true" tabindex="-1"></a>     R \cap_{R} S = \cap_{<span class="sc">\{</span>\tilde{R} | R \cap S \subset \mathbf{R}<span class="sc">\}</span>} \tilde{R}\,,<span class="sc">\\</span></span>
<span id="cb3-370"><a href="#cb3-370" aria-hidden="true" tabindex="-1"></a>      R \setminus_{R} S = \cap_{<span class="sc">\{</span>\tilde{R} | R \setminus S \subset \mathbf{R}<span class="sc">\}</span>} \tilde{R}\,.</span>
<span id="cb3-371"><a href="#cb3-371" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb3-372"><a href="#cb3-372" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-373"><a href="#cb3-373" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-374"><a href="#cb3-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-375"><a href="#cb3-375" aria-hidden="true" tabindex="-1"></a>We now explain how we compute these two operators. First, we note that they can be recovered by solving a $2p$ one-dimensional optimization problem.</span>
<span id="cb3-376"><a href="#cb3-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-377"><a href="#cb3-377" aria-hidden="true" tabindex="-1"></a>:::{#prp-proposition}</span>
<span id="cb3-378"><a href="#cb3-378" aria-hidden="true" tabindex="-1"></a>The $k$-th minimum coordinates $\tilde{l}_k$ and maximum coordinates $\tilde{r}_k$ of   $\tilde{R} = R \cap_{R} S$ (resp. $\tilde{R} = R \setminus_{R} S$) is obtained as</span>
<span id="cb3-379"><a href="#cb3-379" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-380"><a href="#cb3-380" aria-hidden="true" tabindex="-1"></a>    \tilde{l}_k \hbox{ or } \tilde{r}_k = </span>
<span id="cb3-381"><a href="#cb3-381" aria-hidden="true" tabindex="-1"></a>    \left<span class="sc">\{</span></span>
<span id="cb3-382"><a href="#cb3-382" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb3-383"><a href="#cb3-383" aria-hidden="true" tabindex="-1"></a>        &amp;\min_{\theta_k \in \mathbb{R}} \hbox{ or } \max_{\theta_k \in \mathbb{R}}  \theta_k\,,<span class="sc">\\</span></span>
<span id="cb3-384"><a href="#cb3-384" aria-hidden="true" tabindex="-1"></a>        &amp; \hbox{subject to } \varepsilon s(\theta) \le 0 \,,<span class="sc">\\</span></span>
<span id="cb3-385"><a href="#cb3-385" aria-hidden="true" tabindex="-1"></a>        &amp; \quad \quad \quad \quad \quad l_j \le \theta_j \le r_j\,,\quad j = 1,\dots,p \,,<span class="sc">\\</span></span>
<span id="cb3-386"><a href="#cb3-386" aria-hidden="true" tabindex="-1"></a>    \end{aligned}</span>
<span id="cb3-387"><a href="#cb3-387" aria-hidden="true" tabindex="-1"></a>    \right.  </span>
<span id="cb3-388"><a href="#cb3-388" aria-hidden="true" tabindex="-1"></a>$${#eq-inclusionOptim}</span>
<span id="cb3-389"><a href="#cb3-389" aria-hidden="true" tabindex="-1"></a>with $\varepsilon = 1$ (resp. $\varepsilon = -1$). </span>
<span id="cb3-390"><a href="#cb3-390" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-391"><a href="#cb3-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-392"><a href="#cb3-392" aria-hidden="true" tabindex="-1"></a>To solve the previous problems ($\varepsilon = 1$ or $-1$), we define the following characteristic points.</span>
<span id="cb3-393"><a href="#cb3-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-394"><a href="#cb3-394" aria-hidden="true" tabindex="-1"></a>:::{#def-points}</span>
<span id="cb3-395"><a href="#cb3-395" aria-hidden="true" tabindex="-1"></a><span class="fu">## Minimal, closest and farthest points</span></span>
<span id="cb3-396"><a href="#cb3-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-397"><a href="#cb3-397" aria-hidden="true" tabindex="-1"></a>Let $S \in \mathbf{S}$, described by function $s(\theta) = \sum_{k=1}^{p} s^k(\theta^k) - \Delta$ from the family of functions (@eq-setSfunc), with $\theta\in \mathbb{R}^p$. We define the minimal point $\mathbf{c}\in \mathbb{R}^p$ of $S$ as:</span>
<span id="cb3-398"><a href="#cb3-398" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-399"><a href="#cb3-399" aria-hidden="true" tabindex="-1"></a>    \mathbf{c} = \left<span class="sc">\{</span>\mathbf{c}^k\right<span class="sc">\}</span>_{k=1,\dots,p}, \quad \text { with }\quad \mathbf{c}^k =\underset{\theta^k \in \mathbb R} Arg\min <span class="sc">\{</span> s^k(\theta^k) <span class="sc">\}</span>\,.</span>
<span id="cb3-400"><a href="#cb3-400" aria-hidden="true" tabindex="-1"></a>$$ {#eq-c}</span>
<span id="cb3-401"><a href="#cb3-401" aria-hidden="true" tabindex="-1"></a>Moreover, with $R \in \mathbf{R}$ defined through vectors $l,r \in \mathbb{R}^p$, we define two points of $R$, the closest point $\mathbf{m} \in \mathbb{R}^p$ and the farthest point $\mathbf{M} \in \mathbb{R}^p$ relative to $S$ as </span>
<span id="cb3-402"><a href="#cb3-402" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-403"><a href="#cb3-403" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb3-404"><a href="#cb3-404" aria-hidden="true" tabindex="-1"></a>    \mathbf{m} =\left<span class="sc">\{</span>\mathbf{m}^k\right<span class="sc">\}</span>_{k=1,\dots,p},\quad \text { with }\quad </span>
<span id="cb3-405"><a href="#cb3-405" aria-hidden="true" tabindex="-1"></a>    \mathbf{m}^k = \underset{l^k \le \theta^k \le r^k}{Arg\min}  \left<span class="sc">\{</span> s^k(\theta^k)\right<span class="sc">\}</span>,<span class="sc">\\</span></span>
<span id="cb3-406"><a href="#cb3-406" aria-hidden="true" tabindex="-1"></a>    \mathbf{M} =\left<span class="sc">\{</span>\mathbf{M}^k\right<span class="sc">\}</span>_{k=1,\dots,p},\quad \text { with }\quad </span>
<span id="cb3-407"><a href="#cb3-407" aria-hidden="true" tabindex="-1"></a>    \mathbf{M}^k = \underset{l^k \le \theta^k \le r^k}{Arg\max}  \left<span class="sc">\{</span>s^k(\theta^k)\right<span class="sc">\}</span>\,.</span>
<span id="cb3-408"><a href="#cb3-408" aria-hidden="true" tabindex="-1"></a>    \end{aligned}</span>
<span id="cb3-409"><a href="#cb3-409" aria-hidden="true" tabindex="-1"></a>$${#eq-mk}</span>
<span id="cb3-410"><a href="#cb3-410" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-411"><a href="#cb3-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-412"><a href="#cb3-412" aria-hidden="true" tabindex="-1"></a>:::{.remark}</span>
<span id="cb3-413"><a href="#cb3-413" aria-hidden="true" tabindex="-1"></a>In the Gaussian case, $S$ is a ball in $\mathbb{R}^p$ and </span>
<span id="cb3-414"><a href="#cb3-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-415"><a href="#cb3-415" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\mathbf{c}$ is the center of the ball;</span>
<span id="cb3-416"><a href="#cb3-416" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\mathbf{m}$ is the closest point to $\mathbf{c}$ inside $R$;</span>
<span id="cb3-417"><a href="#cb3-417" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\mathbf{M}$ is the farthest point to $\mathbf{c}$ in $R$.</span>
<span id="cb3-418"><a href="#cb3-418" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-419"><a href="#cb3-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-420"><a href="#cb3-420" aria-hidden="true" tabindex="-1"></a>:::{#fig-Figure4}  </span>
<span id="cb3-421"><a href="#cb3-421" aria-hidden="true" tabindex="-1"></a><span class="al">![](images/Figure 4 Minimal closest and farthest points.png)</span></span>
<span id="cb3-422"><a href="#cb3-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-423"><a href="#cb3-423" aria-hidden="true" tabindex="-1"></a>Three examples  of minimal point $\mathbf{c}$, closest point $\mathbf{m}$ and farthest point $\mathbf{M}$ for bi-variate Gaussian case: (a) $R \subset S$; (b) $R \cap S \neq \emptyset$; (c) $R \cap S = \emptyset$.</span>
<span id="cb3-424"><a href="#cb3-424" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-425"><a href="#cb3-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-426"><a href="#cb3-426" aria-hidden="true" tabindex="-1"></a>:::{#prp-prop_solution_rect}</span>
<span id="cb3-427"><a href="#cb3-427" aria-hidden="true" tabindex="-1"></a>Let  $\tilde{R} = R \cap_{R} S$ (resp. $R\setminus_{R} S$), with $R \in \mathbf{R}$ and $S \in \mathbf{S}$. We compute the boundaries $(\tilde{l}, \tilde{r})$ of $\tilde{R}$ using the following rule:</span>
<span id="cb3-428"><a href="#cb3-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-429"><a href="#cb3-429" aria-hidden="true" tabindex="-1"></a>i) We define the point $\tilde{\theta}\in \mathbb{R}^p$ as the closest point $\mathbf{m}$ (resp. farthest $\mathbf{M}$). For all $k = 1,\dots p$ we find the roots $\theta^{k_1}$ and $\theta^{k_2}$ of the one-variable $(\theta^k)$ equation </span>
<span id="cb3-430"><a href="#cb3-430" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-431"><a href="#cb3-431" aria-hidden="true" tabindex="-1"></a>s^k(\theta^k)+\sum_{j\neq k} s^j(\tilde{\theta}^j) -\Delta= 0 \,.</span>
<span id="cb3-432"><a href="#cb3-432" aria-hidden="true" tabindex="-1"></a>$${#eq-eqs_k}</span>
<span id="cb3-433"><a href="#cb3-433" aria-hidden="true" tabindex="-1"></a>If the roots are real-valued we consider that $\theta^{k_1} \le \theta^{k_2}$, otherwise we write $\Big<span class="co">[</span><span class="ot">\theta^{k_1},\theta^{k_2}\Big</span><span class="co">]</span> = \emptyset$.</span>
<span id="cb3-434"><a href="#cb3-434" aria-hidden="true" tabindex="-1"></a>ii) We compute the boundary values $\tilde{l}^k$ and $\tilde{r}^k$ of </span>
<span id="cb3-435"><a href="#cb3-435" aria-hidden="true" tabindex="-1"></a>$\tilde{R}$ as:</span>
<span id="cb3-436"><a href="#cb3-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-437"><a href="#cb3-437" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>For $R\cap_{R} S$ $(k = 1,\dots,p)$:</span>
<span id="cb3-438"><a href="#cb3-438" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-439"><a href="#cb3-439" aria-hidden="true" tabindex="-1"></a>\Big<span class="co">[</span><span class="ot">\tilde{l}^k,\tilde{r}^k\Big</span><span class="co">]</span> = \Big<span class="co">[</span><span class="ot">\theta^{k_1},\theta^{k_2}\Big</span><span class="co">]</span> \cap \Big<span class="co">[</span><span class="ot">l^k, r^k\Big</span><span class="co">]</span>\,.</span>
<span id="cb3-440"><a href="#cb3-440" aria-hidden="true" tabindex="-1"></a>$$  {#eq-updateIntersection}</span>
<span id="cb3-441"><a href="#cb3-441" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>For $R\setminus_{R} S$ $(k = 1,\dots,p)$:</span>
<span id="cb3-442"><a href="#cb3-442" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-443"><a href="#cb3-443" aria-hidden="true" tabindex="-1"></a>\Big<span class="co">[</span><span class="ot">\tilde{l}^k,\tilde{r}^k\Big</span><span class="co">]</span> =</span>
<span id="cb3-444"><a href="#cb3-444" aria-hidden="true" tabindex="-1"></a>\left<span class="sc">\{</span></span>
<span id="cb3-445"><a href="#cb3-445" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb3-446"><a href="#cb3-446" aria-hidden="true" tabindex="-1"></a>&amp; \Big<span class="co">[</span><span class="ot">l^k, r^k\Big</span><span class="co">]</span>  \setminus \Big<span class="co">[</span><span class="ot">\theta^{k_1},\theta^{k_2}\Big</span><span class="co">]</span> \,,  &amp; \hbox{if} \quad \Big<span class="co">[</span><span class="ot">\theta^{k_1},\theta^{k_2}\Big</span><span class="co">]</span> \not\subset \Big<span class="co">[</span><span class="ot">l^k, r^k\Big</span><span class="co">]</span>\,,<span class="sc">\\</span></span>
<span id="cb3-447"><a href="#cb3-447" aria-hidden="true" tabindex="-1"></a>&amp; \Big<span class="co">[</span><span class="ot">l^k, r^k\Big</span><span class="co">]</span>\,, &amp; \hbox{otherwise}\,.<span class="sc">\\</span></span>
<span id="cb3-448"><a href="#cb3-448" aria-hidden="true" tabindex="-1"></a>\end{aligned} </span>
<span id="cb3-449"><a href="#cb3-449" aria-hidden="true" tabindex="-1"></a>\right.</span>
<span id="cb3-450"><a href="#cb3-450" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-451"><a href="#cb3-451" aria-hidden="true" tabindex="-1"></a>If there is a dimension $k$ for which $\Big<span class="co">[</span><span class="ot">\tilde{l}^k, \tilde{r}^k\Big</span><span class="co">]</span>=\emptyset$, then the set $\tilde{R}$ is empty.</span>
<span id="cb3-452"><a href="#cb3-452" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-453"><a href="#cb3-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-454"><a href="#cb3-454" aria-hidden="true" tabindex="-1"></a>The proof of @prp-prop_solution_rect is presented in @sec-proof_prop_solution_rect. </span>
<span id="cb3-455"><a href="#cb3-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-456"><a href="#cb3-456" aria-hidden="true" tabindex="-1"></a><span class="fu"># Simulation Study of GeomFPOP {#sec-study}</span></span>
<span id="cb3-457"><a href="#cb3-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-458"><a href="#cb3-458" aria-hidden="true" tabindex="-1"></a>In this section, we study  the efficiency of GeomFPOP using simulations of multivariate independent time series. For this, we implemented GeomFPOP (with S and R types) and PELT for the Multivariate Independent Gaussian Model in the R-package 'GeomFPOP'  <span class="co">[</span><span class="ot">https://github.com/lpishchagina/GeomFPOP</span><span class="co">](https://github.com/lpishchagina/GeomFPOP)</span>   written in R/C++. By default, the value of penalty $\beta$ for each simulation was defined by the Schwarz Information Criterion proposed in @Yao ($\beta = 2p \log{n}$).</span>
<span id="cb3-459"><a href="#cb3-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-460"><a href="#cb3-460" aria-hidden="true" tabindex="-1"></a>*Overview of our simulations.* First, as a quality control we made sure that the output of PELT and GeomFPOP were identical on a number of simulated profiles. Second, we studied cases where the PELT approach is not efficient, that is when the data has no or few changes relative to $n$. Indeed, it was shown in @Killick and @Maidstone that the run time of PELT is close to $\mathcal{O}(n^2)$ in such cases. So we considered simulations of multivariate time series without change (only one segment). </span>
<span id="cb3-461"><a href="#cb3-461" aria-hidden="true" tabindex="-1"></a>By these simulations we evaluated the pruning efficiency of GeomFPOP (using S and R types) for  dimension $2\le p\le 10$ (see @fig-Figure5 in @sec-NC). </span>
<span id="cb3-462"><a href="#cb3-462" aria-hidden="true" tabindex="-1"></a> For small dimensions ($2 \le p \le 4$)  we also evaluated  the run time of GeomFPOP and  PELT and compare them (see @fig-Figure6 in  @sec-TCsmall).  In addition, we considered  another approximation of the $Z^i_t$ where we applied our $\cap_{R}$ and $\setminus_R$ operators only for a randomly selected subset of the past and future balls. In practice, this strategy turned out to be faster computationally than the full/original GeomFPOP and PELT (see @fig-Figure7 in @sec-GeomFPOP_random). </span>
<span id="cb3-463"><a href="#cb3-463" aria-hidden="true" tabindex="-1"></a>For this strategy we also generated time series of a fixed size ($10^6$ data points) and varying number of segments and evaluated how the run time vary with the number of segments for small dimensions ($2 \le p \le 4$). Our empirical results confirmed that the GeomFPOP (R-type: $\mathtt{random/random}$) approach is computationally comparable to PELT when the number of changes is large (see @fig-Figure9 in @sec-Run_time_segment_nb).</span>
<span id="cb3-464"><a href="#cb3-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-465"><a href="#cb3-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-466"><a href="#cb3-466" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb3-467"><a href="#cb3-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-468"><a href="#cb3-468" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb3-469"><a href="#cb3-469" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-470"><a href="#cb3-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-471"><a href="#cb3-471" aria-hidden="true" tabindex="-1"></a><span class="fu"># Session information {.appendix .unnumbered}</span></span>
<span id="cb3-472"><a href="#cb3-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-473"><a href="#cb3-473" aria-hidden="true" tabindex="-1"></a><span class="in">```{r session-info}</span></span>
<span id="cb3-474"><a href="#cb3-474" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span>
<span id="cb3-475"><a href="#cb3-475" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>